<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" xmlns:lit="http://www.sdml.info/srcML/literal" xmlns:op="http://www.sdml.info/srcML/operator" xmlns:type="http://www.sdml.info/srcML/modifier" xmlns:pos="http://www.sdml.info/srcML/position" language="C#" filename="D:\Research\Subjects\SrcML.NET\ABB.SrcML.Data\CPlusPlusCodeParser.cs" pos:tabs="8"><comment type="block" pos:line="1" pos:column="1">/******************************************************************************
 * Copyright (c) 2013 ABB Group
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Vinay Augustine (ABB Group) - initial API, implementation, &amp; documentation
 *****************************************************************************/</comment>

<using pos:line="12" pos:column="1">using <name pos:line="12" pos:column="7">System</name>;</using>
<using pos:line="13" pos:column="1">using <name><name pos:line="13" pos:column="7">System</name><op:operator pos:line="13" pos:column="13">.</op:operator><name pos:line="13" pos:column="14">Collections</name><op:operator pos:line="13" pos:column="25">.</op:operator><name pos:line="13" pos:column="26">Generic</name></name>;</using>
<using pos:line="14" pos:column="1">using <name><name pos:line="14" pos:column="7">System</name><op:operator pos:line="14" pos:column="13">.</op:operator><name pos:line="14" pos:column="14">Linq</name></name>;</using>
<using pos:line="15" pos:column="1">using <name><name pos:line="15" pos:column="7">System</name><op:operator pos:line="15" pos:column="13">.</op:operator><name pos:line="15" pos:column="14">Xml</name><op:operator pos:line="15" pos:column="17">.</op:operator><name pos:line="15" pos:column="18">Linq</name></name>;</using>

<namespace pos:line="17" pos:column="1">namespace <name><name pos:line="17" pos:column="11">ABB</name><op:operator pos:line="17" pos:column="14">.</op:operator><name pos:line="17" pos:column="15">SrcML</name><op:operator pos:line="17" pos:column="20">.</op:operator><name pos:line="17" pos:column="21">Data</name></name> <block pos:line="17" pos:column="26">{

    <comment type="line" pos:line="19" pos:column="5">/// &lt;summary&gt;</comment>
    <comment type="line" pos:line="20" pos:column="5">/// Provides parsing facilities for the C++ language</comment>
    <comment type="line" pos:line="21" pos:column="5">/// &lt;/summary&gt;</comment>
    <class><specifier pos:line="22" pos:column="5">public</specifier> class <name pos:line="22" pos:column="18">CPlusPlusCodeParser</name> <super pos:line="22" pos:column="38">: <name pos:line="22" pos:column="40">AbstractCodeParser</name></super> <block pos:line="22" pos:column="59">{

        <comment type="line" pos:line="24" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="25" pos:column="9">/// Creates a new C++ code parser object</comment>
        <comment type="line" pos:line="26" pos:column="9">/// &lt;/summary&gt;</comment>
        <constructor><specifier pos:line="27" pos:column="9">public</specifier> <name pos:line="27" pos:column="16">CPlusPlusCodeParser</name><parameter_list pos:line="27" pos:column="35">()</parameter_list> <block pos:line="27" pos:column="38">{
            <expr_stmt><expr><name><name pos:line="28" pos:column="13">this</name><op:operator pos:line="28" pos:column="17">.</op:operator><name pos:line="28" pos:column="18">SpecifierContainerNames</name></name> <op:operator pos:line="28" pos:column="42">=</op:operator> <op:operator pos:line="28" pos:column="44">new</op:operator> <call><name><name pos:line="28" pos:column="48">HashSet</name><argument_list pos:line="28" pos:column="55">&lt;<argument><name pos:line="28" pos:column="56">XName</name></argument>&gt;</argument_list></name><argument_list pos:line="28" pos:column="62">(<argument><expr><op:operator pos:line="28" pos:column="63">new</op:operator> <name><name pos:line="28" pos:column="67">XName</name><index pos:line="28" pos:column="72">[]</index></name> <block pos:line="28" pos:column="75">{ <expr><name><name pos:line="28" pos:column="77">SRC</name><op:operator pos:line="28" pos:column="80">.</op:operator><name pos:line="28" pos:column="81">Private</name></name></expr><op:operator pos:line="28" pos:column="88">,</op:operator> <expr><name><name pos:line="28" pos:column="90">SRC</name><op:operator pos:line="28" pos:column="93">.</op:operator><name pos:line="28" pos:column="94">Protected</name></name></expr><op:operator pos:line="28" pos:column="103">,</op:operator> <expr><name><name pos:line="28" pos:column="105">SRC</name><op:operator pos:line="28" pos:column="108">.</op:operator><name pos:line="28" pos:column="109">Public</name></name></expr> }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name pos:line="29" pos:column="13">this</name><op:operator pos:line="29" pos:column="17">.</op:operator><name pos:line="29" pos:column="18">TypeElementNames</name></name> <op:operator pos:line="29" pos:column="35">=</op:operator> <op:operator pos:line="29" pos:column="37">new</op:operator> <call><name><name pos:line="29" pos:column="41">HashSet</name><argument_list pos:line="29" pos:column="48">&lt;<argument><name pos:line="29" pos:column="49">XName</name></argument>&gt;</argument_list></name><argument_list pos:line="29" pos:column="55">(<argument><expr><op:operator pos:line="29" pos:column="56">new</op:operator> <name><name pos:line="29" pos:column="60">XName</name><index pos:line="29" pos:column="65">[]</index></name> <block pos:line="29" pos:column="68">{
                <expr><name><name pos:line="30" pos:column="17">SRC</name><op:operator pos:line="30" pos:column="20">.</op:operator><name pos:line="30" pos:column="21">Class</name></name></expr><op:operator pos:line="30" pos:column="26">,</op:operator> <expr><name><name pos:line="30" pos:column="28">SRC</name><op:operator pos:line="30" pos:column="31">.</op:operator><name pos:line="30" pos:column="32">Enum</name></name></expr><op:operator pos:line="30" pos:column="36">,</op:operator> <expr><name><name pos:line="30" pos:column="38">SRC</name><op:operator pos:line="30" pos:column="41">.</op:operator><name pos:line="30" pos:column="42">Struct</name></name></expr><op:operator pos:line="30" pos:column="48">,</op:operator> <expr><name><name pos:line="30" pos:column="50">SRC</name><op:operator pos:line="30" pos:column="53">.</op:operator><name pos:line="30" pos:column="54">Union</name></name></expr><op:operator pos:line="30" pos:column="59">,</op:operator>
                <expr><name><name pos:line="31" pos:column="17">SRC</name><op:operator pos:line="31" pos:column="20">.</op:operator><name pos:line="31" pos:column="21">ClassDeclaration</name></name></expr><op:operator pos:line="31" pos:column="37">,</op:operator> <expr><name><name pos:line="31" pos:column="39">SRC</name><op:operator pos:line="31" pos:column="42">.</op:operator><name pos:line="31" pos:column="43">StructDeclaration</name></name></expr><op:operator pos:line="31" pos:column="60">,</op:operator> <expr><name><name pos:line="31" pos:column="62">SRC</name><op:operator pos:line="31" pos:column="65">.</op:operator><name pos:line="31" pos:column="66">UnionDeclaration</name></name></expr>
            }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name pos:line="33" pos:column="13">this</name><op:operator pos:line="33" pos:column="17">.</op:operator><name pos:line="33" pos:column="18">VariableDeclarationElementNames</name></name> <op:operator pos:line="33" pos:column="50">=</op:operator> <op:operator pos:line="33" pos:column="52">new</op:operator> <call><name><name pos:line="33" pos:column="56">HashSet</name><argument_list pos:line="33" pos:column="63">&lt;<argument><name pos:line="33" pos:column="64">XName</name></argument>&gt;</argument_list></name><argument_list pos:line="33" pos:column="70">(<argument><expr><op:operator pos:line="33" pos:column="71">new</op:operator> <name><name pos:line="33" pos:column="75">XName</name><index pos:line="33" pos:column="80">[]</index></name> <block pos:line="33" pos:column="83">{ <expr><name><name pos:line="33" pos:column="85">SRC</name><op:operator pos:line="33" pos:column="88">.</op:operator><name pos:line="33" pos:column="89">Declaration</name></name></expr><op:operator pos:line="33" pos:column="100">,</op:operator> <expr><name><name pos:line="33" pos:column="102">SRC</name><op:operator pos:line="33" pos:column="105">.</op:operator><name pos:line="33" pos:column="106">DeclarationStatement</name></name></expr><op:operator pos:line="33" pos:column="126">,</op:operator> <expr><name><name pos:line="33" pos:column="128">SRC</name><op:operator pos:line="33" pos:column="131">.</op:operator><name pos:line="33" pos:column="132">FunctionDeclaration</name></name></expr> }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name pos:line="34" pos:column="13">this</name><op:operator pos:line="34" pos:column="17">.</op:operator><name pos:line="34" pos:column="18">AliasElementName</name></name> <op:operator pos:line="34" pos:column="35">=</op:operator> <name><name pos:line="34" pos:column="37">SRC</name><op:operator pos:line="34" pos:column="40">.</op:operator><name pos:line="34" pos:column="41">Using</name></name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="line" pos:line="37" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="38" pos:column="9">/// Returns &lt;c&gt;Language.CPlusPlus&lt;/c&gt;</comment>
        <comment type="line" pos:line="39" pos:column="9">/// &lt;/summary&gt;</comment>
        <decl_stmt><decl><type><specifier pos:line="40" pos:column="9">public</specifier> <specifier pos:line="40" pos:column="16">override</specifier> <name pos:line="40" pos:column="25">Language</name></type> <name pos:line="40" pos:column="34">ParserLanguage</name> <block pos:line="40" pos:column="49">{
            <function><name pos:line="41" pos:column="13">get</name> <block pos:line="41" pos:column="17">{ <return pos:line="41" pos:column="19">return <expr><name><name pos:line="41" pos:column="26">Language</name><op:operator pos:line="41" pos:column="34">.</op:operator><name pos:line="41" pos:column="35">CPlusPlus</name></name></expr>;</return> }</block></function>
        }</block></decl></decl_stmt>

        <comment type="line" pos:line="44" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="45" pos:column="9">/// Returns the list of specifier containers (&lt;see cref="ABB.SrcML.SRC.Private"/&gt;,</comment>
        <comment type="line" pos:line="46" pos:column="9">/// &lt;see cref="ABB.SrcML.SRC.Protected"/&gt;, and &lt;see cref="ABB.SrcML.SRC.Public"/&gt;</comment>
        <comment type="line" pos:line="47" pos:column="9">/// &lt;/summary&gt;</comment>
        <decl_stmt><decl><type><specifier pos:line="48" pos:column="9">public</specifier> <name><name pos:line="48" pos:column="16">HashSet</name><argument_list pos:line="48" pos:column="23">&lt;<argument><name pos:line="48" pos:column="24">XName</name></argument>&gt;</argument_list></name></type> <name pos:line="48" pos:column="31">SpecifierContainerNames</name> <block pos:line="48" pos:column="55">{ <function_decl><name pos:line="48" pos:column="57">get</name>;</function_decl> <function_decl><name pos:line="48" pos:column="62">set</name>;</function_decl> }</block></decl></decl_stmt>


        <comment type="line" pos:line="51" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="52" pos:column="9">/// Gets the access modifiers for this method. In C++, methods are contained within</comment>
        <comment type="line" pos:line="53" pos:column="9">/// "specifier" blocks</comment>
        <comment type="line" pos:line="54" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="55" pos:column="9">/// &lt;param name="methodElement"&gt;The method typeUseElement&lt;/param&gt;</comment>
        <comment type="line" pos:line="56" pos:column="9">/// &lt;returns&gt;The access modifier for this method; if none, it returns see</comment>
        <comment type="line" pos:line="57" pos:column="9">/// cref="AccessModifier.None"/&gt;&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="58" pos:column="9">protected</specifier> <specifier pos:line="58" pos:column="19">override</specifier> <name pos:line="58" pos:column="28">AccessModifier</name></type> <name pos:line="58" pos:column="43">GetAccessModifierForMethod</name><parameter_list pos:line="58" pos:column="69">(<param><decl><type><name pos:line="58" pos:column="70">XElement</name></type> <name pos:line="58" pos:column="79">methodElement</name></decl></param>)</parameter_list> <block pos:line="58" pos:column="94">{
            <decl_stmt><decl><type><name><name pos:line="59" pos:column="13">Dictionary</name><argument_list pos:line="59" pos:column="23">&lt;<argument><name pos:line="59" pos:column="24">XName</name></argument>, <argument><name pos:line="59" pos:column="31">AccessModifier</name></argument>&gt;</argument_list></name></type> <name pos:line="59" pos:column="47">accessModifierMap</name> <init pos:line="59" pos:column="65">= <expr><op:operator pos:line="59" pos:column="67">new</op:operator> <call><name><name pos:line="59" pos:column="71">Dictionary</name><argument_list pos:line="59" pos:column="81">&lt;<argument><name pos:line="59" pos:column="82">XName</name></argument>, <argument><name pos:line="59" pos:column="89">AccessModifier</name></argument>&gt;</argument_list></name><argument_list pos:line="59" pos:column="104">()</argument_list></call> <block pos:line="59" pos:column="107">{
                <expr><block pos:line="60" pos:column="17">{ <expr><name><name pos:line="60" pos:column="19">SRC</name><op:operator pos:line="60" pos:column="22">.</op:operator><name pos:line="60" pos:column="23">Public</name></name></expr>, <expr><name><name pos:line="60" pos:column="31">AccessModifier</name><op:operator pos:line="60" pos:column="45">.</op:operator><name pos:line="60" pos:column="46">Public</name></name></expr> }</block></expr>,
                <expr><block pos:line="61" pos:column="17">{ <expr><name><name pos:line="61" pos:column="19">SRC</name><op:operator pos:line="61" pos:column="22">.</op:operator><name pos:line="61" pos:column="23">Private</name></name></expr>, <expr><name><name pos:line="61" pos:column="32">AccessModifier</name><op:operator pos:line="61" pos:column="46">.</op:operator><name pos:line="61" pos:column="47">Private</name></name></expr> }</block></expr>,
                <expr><block pos:line="62" pos:column="17">{ <expr><name><name pos:line="62" pos:column="19">SRC</name><op:operator pos:line="62" pos:column="22">.</op:operator><name pos:line="62" pos:column="23">Protected</name></name></expr>, <expr><name><name pos:line="62" pos:column="34">AccessModifier</name><op:operator pos:line="62" pos:column="48">.</op:operator><name pos:line="62" pos:column="49">Protected</name></name></expr> }</block></expr>,
            }</block></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name pos:line="65" pos:column="13">var</name></type> <name pos:line="65" pos:column="17">specifiers</name> <init pos:line="65" pos:column="28">= <expr><linq><from pos:line="65" pos:column="30">from <expr><name pos:line="65" pos:column="35">container</name></expr> <in pos:line="65" pos:column="45">in <expr><call><name><name pos:line="65" pos:column="48">methodElement</name><op:operator pos:line="65" pos:column="61">.</op:operator><name pos:line="65" pos:column="62">Ancestors</name></name><argument_list pos:line="65" pos:column="71">()</argument_list></call></expr></in></from>
                             <where pos:line="66" pos:column="30">where <expr><call><name><name pos:line="66" pos:column="36">SpecifierContainerNames</name><op:operator pos:line="66" pos:column="59">.</op:operator><name pos:line="66" pos:column="60">Contains</name></name><argument_list pos:line="66" pos:column="68">(<argument><expr><name><name pos:line="66" pos:column="69">container</name><op:operator pos:line="66" pos:column="78">.</op:operator><name pos:line="66" pos:column="79">Name</name></name></expr></argument>)</argument_list></call></expr></where>
                             <select pos:line="67" pos:column="30">select <expr><name><name pos:line="67" pos:column="37">accessModifierMap</name><index pos:line="67" pos:column="54">[<expr><name><name pos:line="67" pos:column="55">container</name><op:operator pos:line="67" pos:column="64">.</op:operator><name pos:line="67" pos:column="65">Name</name></name></expr>]</index></name></expr></select></linq></expr></init></decl>;</decl_stmt>

            <return pos:line="69" pos:column="13">return <expr><op:operator pos:line="69" pos:column="20">(</op:operator><call><name><name pos:line="69" pos:column="21">specifiers</name><op:operator pos:line="69" pos:column="31">.</op:operator><name pos:line="69" pos:column="32">Any</name></name><argument_list pos:line="69" pos:column="35">()</argument_list></call> <op:operator pos:line="69" pos:column="38">?</op:operator> <call><name><name pos:line="69" pos:column="40">specifiers</name><op:operator pos:line="69" pos:column="50">.</op:operator><name pos:line="69" pos:column="51">First</name></name><argument_list pos:line="69" pos:column="56">()</argument_list></call> <op:operator pos:line="69" pos:column="59">:</op:operator> <name><name pos:line="69" pos:column="61">AccessModifier</name><op:operator pos:line="69" pos:column="75">.</op:operator><name pos:line="69" pos:column="76">None</name></name><op:operator pos:line="69" pos:column="80">)</op:operator></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="72" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="73" pos:column="9">/// Gets the access modifier for this type. In C++, all types are public, so this always</comment>
        <comment type="line" pos:line="74" pos:column="9">/// returns "public"</comment>
        <comment type="line" pos:line="75" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="76" pos:column="9">/// &lt;param name="typeElement"&gt;The type&lt;/param&gt;</comment>
        <comment type="line" pos:line="77" pos:column="9">/// &lt;returns&gt;the access modifier for this type.&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="78" pos:column="9">protected</specifier> <specifier pos:line="78" pos:column="19">override</specifier> <name pos:line="78" pos:column="28">AccessModifier</name></type> <name pos:line="78" pos:column="43">GetAccessModifierForType</name><parameter_list pos:line="78" pos:column="67">(<param><decl><type><name pos:line="78" pos:column="68">XElement</name></type> <name pos:line="78" pos:column="77">typeElement</name></decl></param>)</parameter_list> <block pos:line="78" pos:column="90">{
            <return pos:line="79" pos:column="13">return <expr><name><name pos:line="79" pos:column="20">AccessModifier</name><op:operator pos:line="79" pos:column="34">.</op:operator><name pos:line="79" pos:column="35">None</name></name></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="82" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="83" pos:column="9">/// Gets the name for a method. This is the unqualified name, not any class names that might</comment>
        <comment type="line" pos:line="84" pos:column="9">/// be prepended to it.</comment>
        <comment type="line" pos:line="85" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="86" pos:column="9">/// &lt;param name="methodElement"&gt;The method typeUseElement&lt;/param&gt;</comment>
        <comment type="line" pos:line="87" pos:column="9">/// &lt;returns&gt;a string with the method name&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="88" pos:column="9">protected</specifier> <specifier pos:line="88" pos:column="19">override</specifier> <name pos:line="88" pos:column="28">string</name></type> <name pos:line="88" pos:column="35">GetNameForMethod</name><parameter_list pos:line="88" pos:column="51">(<param><decl><type><name pos:line="88" pos:column="52">XElement</name></type> <name pos:line="88" pos:column="61">methodElement</name></decl></param>)</parameter_list> <block pos:line="88" pos:column="76">{
            <decl_stmt><decl><type><name pos:line="89" pos:column="13">var</name></type> <name pos:line="89" pos:column="17">nameElement</name> <init pos:line="89" pos:column="29">= <expr><call><name><name pos:line="89" pos:column="31">methodElement</name><op:operator pos:line="89" pos:column="44">.</op:operator><name pos:line="89" pos:column="45">Element</name></name><argument_list pos:line="89" pos:column="52">(<argument><expr><name><name pos:line="89" pos:column="53">SRC</name><op:operator pos:line="89" pos:column="56">.</op:operator><name pos:line="89" pos:column="57">Name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if pos:line="91" pos:column="13">if<condition pos:line="91" pos:column="15">(<expr><name pos:line="91" pos:column="16">null</name> <op:operator pos:line="91" pos:column="21">==</op:operator> <name pos:line="91" pos:column="24">nameElement</name></expr>)</condition><then pos:line="91" pos:column="36">
                <return pos:line="92" pos:column="17">return <expr><name><name pos:line="92" pos:column="24">string</name><op:operator pos:line="92" pos:column="30">.</op:operator><name pos:line="92" pos:column="31">Empty</name></name></expr>;</return></then></if>
            <return pos:line="93" pos:column="13">return <expr><call><name><name pos:line="93" pos:column="20">NameHelper</name><op:operator pos:line="93" pos:column="30">.</op:operator><name pos:line="93" pos:column="31">GetLastName</name></name><argument_list pos:line="93" pos:column="42">(<argument><expr><name pos:line="93" pos:column="43">nameElement</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="96" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="97" pos:column="9">/// Checks if the method element has only one parameter "void" (which is really zero</comment>
        <comment type="line" pos:line="98" pos:column="9">/// parameters in C/C++). If not, it just calls</comment>
        <comment type="line" pos:line="99" pos:column="9">/// &lt;see cref="AbstractCodeParser.GetParametersFromMethodElement(XElement)"/&gt;</comment>
        <comment type="line" pos:line="100" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="101" pos:column="9">/// &lt;param name="methodElement"&gt;The method to get parameter elements for&lt;/param&gt;</comment>
        <comment type="line" pos:line="102" pos:column="9">/// &lt;returns&gt;An enumerable of parameter elements&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="103" pos:column="9">protected</specifier> <specifier pos:line="103" pos:column="19">override</specifier> <name><name pos:line="103" pos:column="28">IEnumerable</name><argument_list pos:line="103" pos:column="39">&lt;<argument><name pos:line="103" pos:column="40">XElement</name></argument>&gt;</argument_list></name></type> <name pos:line="103" pos:column="50">GetParametersFromMethodElement</name><parameter_list pos:line="103" pos:column="80">(<param><decl><type><name pos:line="103" pos:column="81">XElement</name></type> <name pos:line="103" pos:column="90">methodElement</name></decl></param>)</parameter_list> <block pos:line="103" pos:column="105">{
            <decl_stmt><decl><type><name pos:line="104" pos:column="13">var</name></type> <name pos:line="104" pos:column="17">paramElements</name> <init pos:line="104" pos:column="31">= <expr><call><name><name pos:line="104" pos:column="33">methodElement</name><op:operator pos:line="104" pos:column="46">.</op:operator><name pos:line="104" pos:column="47">Element</name></name><argument_list pos:line="104" pos:column="54">(<argument><expr><name><name pos:line="104" pos:column="55">SRC</name><op:operator pos:line="104" pos:column="58">.</op:operator><name pos:line="104" pos:column="59">ParameterList</name></name></expr></argument>)</argument_list></call><op:operator pos:line="104" pos:column="73">.</op:operator><call><name pos:line="104" pos:column="74">Elements</name><argument_list pos:line="104" pos:column="82">(<argument><expr><name><name pos:line="104" pos:column="83">SRC</name><op:operator pos:line="104" pos:column="86">.</op:operator><name pos:line="104" pos:column="87">Parameter</name></name></expr></argument>)</argument_list></call><op:operator pos:line="104" pos:column="97">.</op:operator><call><name pos:line="104" pos:column="98">ToList</name><argument_list pos:line="104" pos:column="104">()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if pos:line="105" pos:column="13">if<condition pos:line="105" pos:column="15">(<expr><call><name><name pos:line="105" pos:column="16">paramElements</name><op:operator pos:line="105" pos:column="29">.</op:operator><name pos:line="105" pos:column="30">Count</name></name><argument_list pos:line="105" pos:column="35">()</argument_list></call> <op:operator pos:line="105" pos:column="38">==</op:operator> <lit:literal type="number" pos:line="105" pos:column="41">1</lit:literal> <op:operator pos:line="105" pos:column="43">&amp;&amp;</op:operator> <call><name><name pos:line="105" pos:column="46">paramElements</name><op:operator pos:line="105" pos:column="59">.</op:operator><name pos:line="105" pos:column="60">First</name></name><argument_list pos:line="105" pos:column="65">()</argument_list></call><op:operator pos:line="105" pos:column="67">.</op:operator><name pos:line="105" pos:column="68">Value</name> <op:operator pos:line="105" pos:column="74">==</op:operator> <lit:literal type="string" pos:line="105" pos:column="77">"void"</lit:literal></expr>)</condition><then pos:line="105" pos:column="84"> <block pos:line="105" pos:column="85">{
                <comment type="line" pos:line="106" pos:column="17">//there's only a single "void" parameter, which actually means there are no parameters</comment>
                <return pos:line="107" pos:column="17">return <expr><call><name><name pos:line="107" pos:column="24">Enumerable</name><op:operator pos:line="107" pos:column="34">.</op:operator><name><name pos:line="107" pos:column="35">Empty</name><argument_list pos:line="107" pos:column="40">&lt;<argument><name pos:line="107" pos:column="41">XElement</name></argument>&gt;</argument_list></name></name><argument_list pos:line="107" pos:column="50">()</argument_list></call></expr>;</return>
            }</block></then> <else pos:line="108" pos:column="15">else <block pos:line="108" pos:column="20">{
                <return pos:line="109" pos:column="17">return <expr><call><name><name pos:line="109" pos:column="24">base</name><op:operator pos:line="109" pos:column="28">.</op:operator><name pos:line="109" pos:column="29">GetParametersFromMethodElement</name></name><argument_list pos:line="109" pos:column="59">(<argument><expr><name pos:line="109" pos:column="60">methodElement</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></function>

        <comment type="line" pos:line="113" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="114" pos:column="9">/// Gets the parent types for this type. It parses the C++ ":" operator that appears in type</comment>
        <comment type="line" pos:line="115" pos:column="9">/// definitions.</comment>
        <comment type="line" pos:line="116" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="117" pos:column="9">/// &lt;param name="typeElement"&gt;The type typeUseElement&lt;/param&gt;</comment>
        <comment type="line" pos:line="118" pos:column="9">/// &lt;returns&gt;A collection of type use elements that represent the parent classes&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="119" pos:column="9">protected</specifier> <specifier pos:line="119" pos:column="19">override</specifier> <name><name pos:line="119" pos:column="28">IEnumerable</name><argument_list pos:line="119" pos:column="39">&lt;<argument><name pos:line="119" pos:column="40">XElement</name></argument>&gt;</argument_list></name></type> <name pos:line="119" pos:column="50">GetParentTypeUseElements</name><parameter_list pos:line="119" pos:column="74">(<param><decl><type><name pos:line="119" pos:column="75">XElement</name></type> <name pos:line="119" pos:column="84">typeElement</name></decl></param>)</parameter_list> <block pos:line="119" pos:column="97">{
            <decl_stmt><decl><type><name pos:line="120" pos:column="13">var</name></type> <name pos:line="120" pos:column="17">superTag</name> <init pos:line="120" pos:column="26">= <expr><call><name><name pos:line="120" pos:column="28">typeElement</name><op:operator pos:line="120" pos:column="39">.</op:operator><name pos:line="120" pos:column="40">Element</name></name><argument_list pos:line="120" pos:column="47">(<argument><expr><name><name pos:line="120" pos:column="48">SRC</name><op:operator pos:line="120" pos:column="51">.</op:operator><name pos:line="120" pos:column="52">Super</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if pos:line="122" pos:column="13">if<condition pos:line="122" pos:column="15">(<expr><name pos:line="122" pos:column="16">null</name> <op:operator pos:line="122" pos:column="21">!=</op:operator> <name pos:line="122" pos:column="24">superTag</name></expr>)</condition><then pos:line="122" pos:column="33"> <block pos:line="122" pos:column="34">{
                <return pos:line="123" pos:column="17">return <expr><call><name><name pos:line="123" pos:column="24">superTag</name><op:operator pos:line="123" pos:column="32">.</op:operator><name pos:line="123" pos:column="33">Elements</name></name><argument_list pos:line="123" pos:column="41">(<argument><expr><name><name pos:line="123" pos:column="42">SRC</name><op:operator pos:line="123" pos:column="45">.</op:operator><name pos:line="123" pos:column="46">Name</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <return pos:line="125" pos:column="13">return <expr><call><name><name pos:line="125" pos:column="20">Enumerable</name><op:operator pos:line="125" pos:column="30">.</op:operator><name><name pos:line="125" pos:column="31">Empty</name><argument_list pos:line="125" pos:column="36">&lt;<argument><name pos:line="125" pos:column="37">XElement</name></argument>&gt;</argument_list></name></name><argument_list pos:line="125" pos:column="46">()</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="128" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="129" pos:column="9">/// Parses a C++ boolean literal</comment>
        <comment type="line" pos:line="130" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="131" pos:column="9">/// &lt;param name="literalValue"&gt;The literal value&lt;/param&gt;</comment>
        <comment type="line" pos:line="132" pos:column="9">/// &lt;returns&gt;Returns "bool"&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="133" pos:column="9">protected</specifier> <specifier pos:line="133" pos:column="19">override</specifier> <name pos:line="133" pos:column="28">string</name></type> <name pos:line="133" pos:column="35">GetTypeForBooleanLiteral</name><parameter_list pos:line="133" pos:column="59">(<param><decl><type><name pos:line="133" pos:column="60">string</name></type> <name pos:line="133" pos:column="67">literalValue</name></decl></param>)</parameter_list> <block pos:line="133" pos:column="81">{
            <return pos:line="134" pos:column="13">return <expr><lit:literal type="string" pos:line="134" pos:column="20">"bool"</lit:literal></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="137" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="138" pos:column="9">/// Parses a C++ character literal</comment>
        <comment type="line" pos:line="139" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="140" pos:column="9">/// &lt;param name="literalValue"&gt;The literal value&lt;/param&gt;</comment>
        <comment type="line" pos:line="141" pos:column="9">/// &lt;returns&gt;Returns "char"&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="142" pos:column="9">protected</specifier> <specifier pos:line="142" pos:column="19">override</specifier> <name pos:line="142" pos:column="28">string</name></type> <name pos:line="142" pos:column="35">GetTypeForCharacterLiteral</name><parameter_list pos:line="142" pos:column="61">(<param><decl><type><name pos:line="142" pos:column="62">string</name></type> <name pos:line="142" pos:column="69">literalValue</name></decl></param>)</parameter_list> <block pos:line="142" pos:column="83">{
            <return pos:line="143" pos:column="13">return <expr><lit:literal type="string" pos:line="143" pos:column="20">"char"</lit:literal></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="146" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="147" pos:column="9">/// Parses a C++ number literal</comment>
        <comment type="line" pos:line="148" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="149" pos:column="9">/// &lt;param name="literalValue"&gt;The literal value&lt;/param&gt;</comment>
        <comment type="line" pos:line="150" pos:column="9">/// &lt;returns&gt;Uses &lt;see href="http://www.cplusplus.com/doc/tutorial/constants/"&gt;C++ number</comment>
        <comment type="line" pos:line="151" pos:column="9">/// rules&lt;/see&gt; to determine the proper type&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="152" pos:column="9">protected</specifier> <specifier pos:line="152" pos:column="19">override</specifier> <name pos:line="152" pos:column="28">string</name></type> <name pos:line="152" pos:column="35">GetTypeForNumberLiteral</name><parameter_list pos:line="152" pos:column="58">(<param><decl><type><name pos:line="152" pos:column="59">string</name></type> <name pos:line="152" pos:column="66">literalValue</name></decl></param>)</parameter_list> <block pos:line="152" pos:column="80">{
            <comment type="line" pos:line="153" pos:column="13">// rules taken from: http://www.cplusplus.com/doc/tutorial/constants/ double rules:</comment>
            <comment type="line" pos:line="154" pos:column="13">// contains '.', 'e', 'E' long double also ends in 'L'</comment>
            <comment type="line" pos:line="155" pos:column="13">// float: ends in 'f' or 'F'</comment>
            <comment type="line" pos:line="156" pos:column="13">//if(literalValue.cont</comment>
            <comment type="line" pos:line="157" pos:column="13">// otherwise it's an integer</comment>
            <comment type="line" pos:line="158" pos:column="13">// ends with 'u' indicates "unsigned int"</comment>
            <comment type="line" pos:line="159" pos:column="13">// ends with 'l' indicates "long"</comment>
            <comment type="line" pos:line="160" pos:column="13">// ends with 'ul' indicates "unsigned long"</comment>
            <throw pos:line="161" pos:column="13">throw <expr><op:operator pos:line="161" pos:column="19">new</op:operator> <call><name pos:line="161" pos:column="23">NotImplementedException</name><argument_list pos:line="161" pos:column="46">()</argument_list></call></expr>;</throw>
        }</block></function>

        <comment type="line" pos:line="164" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="165" pos:column="9">/// Parses a C++ string literal</comment>
        <comment type="line" pos:line="166" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="167" pos:column="9">/// &lt;param name="literalValue"&gt;The literal value&lt;/param&gt;</comment>
        <comment type="line" pos:line="168" pos:column="9">/// &lt;returns&gt;Returns "char*"&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="169" pos:column="9">protected</specifier> <specifier pos:line="169" pos:column="19">override</specifier> <name pos:line="169" pos:column="28">string</name></type> <name pos:line="169" pos:column="35">GetTypeForStringLiteral</name><parameter_list pos:line="169" pos:column="58">(<param><decl><type><name pos:line="169" pos:column="59">string</name></type> <name pos:line="169" pos:column="66">literalValue</name></decl></param>)</parameter_list> <block pos:line="169" pos:column="80">{
            <return pos:line="170" pos:column="13">return <expr><lit:literal type="string" pos:line="170" pos:column="20">"char*"</lit:literal></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="173" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="174" pos:column="9">/// Creates a method definition object from</comment>
        <comment type="line" pos:line="175" pos:column="9">/// &lt;paramref name="methodElement"/&gt;. For C++, it looks for something like &lt;code&gt;int A::B::Foo(){ }&lt;/code&gt;</comment>
        <comment type="line" pos:line="176" pos:column="9">/// and adds "A::B" as the NamePrefix.</comment>
        <comment type="line" pos:line="177" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="178" pos:column="9">/// &lt;param name="methodElement"&gt;The method element to parse. This must be one of the elements contained in MethodElementNames.&lt;/param&gt;</comment>
        <comment type="line" pos:line="179" pos:column="9">/// &lt;param name="context"&gt;The parser context&lt;/param&gt;</comment>
        <comment type="line" pos:line="180" pos:column="9">/// &lt;returns&gt;The method definition object for &lt;paramref name="methodElement"/&gt;&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="181" pos:column="9">protected</specifier> <specifier pos:line="181" pos:column="19">override</specifier> <name pos:line="181" pos:column="28">MethodDefinition</name></type> <name pos:line="181" pos:column="45">ParseMethodElement</name><parameter_list pos:line="181" pos:column="63">(<param><decl><type><name pos:line="181" pos:column="64">XElement</name></type> <name pos:line="181" pos:column="73">methodElement</name></decl></param>, <param><decl><type><name pos:line="181" pos:column="88">ParserContext</name></type> <name pos:line="181" pos:column="102">context</name></decl></param>)</parameter_list> <block pos:line="181" pos:column="111">{
            <decl_stmt><decl><type><name pos:line="182" pos:column="13">var</name></type> <name pos:line="182" pos:column="17">md</name> <init pos:line="182" pos:column="20">= <expr><call><name><name pos:line="182" pos:column="22">base</name><op:operator pos:line="182" pos:column="26">.</op:operator><name pos:line="182" pos:column="27">ParseMethodElement</name></name><argument_list pos:line="182" pos:column="45">(<argument><expr><name pos:line="182" pos:column="46">methodElement</name></expr></argument>, <argument><expr><name pos:line="182" pos:column="61">context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name pos:line="183" pos:column="13">var</name></type> <name pos:line="183" pos:column="17">nameElement</name> <init pos:line="183" pos:column="29">= <expr><call><name><name pos:line="183" pos:column="31">methodElement</name><op:operator pos:line="183" pos:column="44">.</op:operator><name pos:line="183" pos:column="45">Element</name></name><argument_list pos:line="183" pos:column="52">(<argument><expr><name><name pos:line="183" pos:column="53">SRC</name><op:operator pos:line="183" pos:column="56">.</op:operator><name pos:line="183" pos:column="57">Name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if pos:line="184" pos:column="13">if<condition pos:line="184" pos:column="15">(<expr><name pos:line="184" pos:column="16">nameElement</name> <op:operator pos:line="184" pos:column="28">!=</op:operator> <name pos:line="184" pos:column="31">null</name></expr>)</condition><then pos:line="184" pos:column="36"> <block pos:line="184" pos:column="37">{
                <expr_stmt><expr><name><name pos:line="185" pos:column="17">md</name><op:operator pos:line="185" pos:column="19">.</op:operator><name pos:line="185" pos:column="20">Prefix</name></name> <op:operator pos:line="185" pos:column="27">=</op:operator> <call><name pos:line="185" pos:column="29">ParseNamePrefix</name><argument_list pos:line="185" pos:column="44">(<argument><expr><name pos:line="185" pos:column="45">nameElement</name></expr></argument>, <argument><expr><name pos:line="185" pos:column="58">context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return pos:line="187" pos:column="13">return <expr><name pos:line="187" pos:column="20">md</name></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="190" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="191" pos:column="9">/// Creates a NamespaceDefinition object for the given namespace typeUseElement. This must</comment>
        <comment type="line" pos:line="192" pos:column="9">/// be one of the typeUseElement types defined in NamespaceElementNames.</comment>
        <comment type="line" pos:line="193" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="194" pos:column="9">/// &lt;param name="namespaceElement"&gt;the namespace element&lt;/param&gt;</comment>
        <comment type="line" pos:line="195" pos:column="9">/// &lt;param name="context"&gt;The parser context&lt;/param&gt;</comment>
        <comment type="line" pos:line="196" pos:column="9">/// &lt;returns&gt;a new NamespaceDefinition object&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="197" pos:column="9">protected</specifier> <specifier pos:line="197" pos:column="19">override</specifier> <name pos:line="197" pos:column="28">NamespaceDefinition</name></type> <name pos:line="197" pos:column="48">ParseNamespaceElement</name><parameter_list pos:line="197" pos:column="69">(<param><decl><type><name pos:line="197" pos:column="70">XElement</name></type> <name pos:line="197" pos:column="79">namespaceElement</name></decl></param>, <param><decl><type><name pos:line="197" pos:column="97">ParserContext</name></type> <name pos:line="197" pos:column="111">context</name></decl></param>)</parameter_list> <block pos:line="197" pos:column="120">{
            <if pos:line="198" pos:column="13">if<condition pos:line="198" pos:column="15">(<expr><name pos:line="198" pos:column="16">namespaceElement</name> <op:operator pos:line="198" pos:column="33">==</op:operator> <name pos:line="198" pos:column="36">null</name></expr>)</condition><then pos:line="198" pos:column="41">
                <throw pos:line="199" pos:column="17">throw <expr><op:operator pos:line="199" pos:column="23">new</op:operator> <call><name pos:line="199" pos:column="27">ArgumentNullException</name><argument_list pos:line="199" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="199" pos:column="49">"namespaceElement"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <if pos:line="200" pos:column="13">if<condition pos:line="200" pos:column="15">(<expr><op:operator pos:line="200" pos:column="16">!</op:operator><call><name><name pos:line="200" pos:column="17">NamespaceElementNames</name><op:operator pos:line="200" pos:column="38">.</op:operator><name pos:line="200" pos:column="39">Contains</name></name><argument_list pos:line="200" pos:column="47">(<argument><expr><name><name pos:line="200" pos:column="48">namespaceElement</name><op:operator pos:line="200" pos:column="64">.</op:operator><name pos:line="200" pos:column="65">Name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then pos:line="200" pos:column="71">
                <throw pos:line="201" pos:column="17">throw <expr><op:operator pos:line="201" pos:column="23">new</op:operator> <call><name pos:line="201" pos:column="27">ArgumentException</name><argument_list pos:line="201" pos:column="44">(<argument><expr><call><name><name pos:line="201" pos:column="45">string</name><op:operator pos:line="201" pos:column="51">.</op:operator><name pos:line="201" pos:column="52">Format</name></name><argument_list pos:line="201" pos:column="58">(<argument><expr><lit:literal type="string" pos:line="201" pos:column="59">"Not a valid namespace element: {0}"</lit:literal></expr></argument>, <argument><expr><name><name pos:line="201" pos:column="97">namespaceElement</name><op:operator pos:line="201" pos:column="113">.</op:operator><name pos:line="201" pos:column="114">Name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lit:literal type="string" pos:line="201" pos:column="121">"namespaceElement"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <if pos:line="202" pos:column="13">if<condition pos:line="202" pos:column="15">(<expr><name pos:line="202" pos:column="16">context</name> <op:operator pos:line="202" pos:column="24">==</op:operator> <name pos:line="202" pos:column="27">null</name></expr>)</condition><then pos:line="202" pos:column="32">
                <throw pos:line="203" pos:column="17">throw <expr><op:operator pos:line="203" pos:column="23">new</op:operator> <call><name pos:line="203" pos:column="27">ArgumentNullException</name><argument_list pos:line="203" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="203" pos:column="49">"context"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name pos:line="205" pos:column="13">var</name></type> <name pos:line="205" pos:column="17">nameElement</name> <init pos:line="205" pos:column="29">= <expr><call><name><name pos:line="205" pos:column="31">namespaceElement</name><op:operator pos:line="205" pos:column="47">.</op:operator><name pos:line="205" pos:column="48">Element</name></name><argument_list pos:line="205" pos:column="55">(<argument><expr><name><name pos:line="205" pos:column="56">SRC</name><op:operator pos:line="205" pos:column="59">.</op:operator><name pos:line="205" pos:column="60">Name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name pos:line="206" pos:column="13">var</name></type> <name pos:line="206" pos:column="17">namespaceName</name> <init pos:line="206" pos:column="31">= <expr><name pos:line="206" pos:column="33">nameElement</name> <op:operator pos:line="206" pos:column="45">!=</op:operator> <name pos:line="206" pos:column="48">null</name> <op:operator pos:line="206" pos:column="53">?</op:operator> <name><name pos:line="206" pos:column="55">nameElement</name><op:operator pos:line="206" pos:column="66">.</op:operator><name pos:line="206" pos:column="67">Value</name></name> <op:operator pos:line="206" pos:column="73">:</op:operator> <name><name pos:line="206" pos:column="75">string</name><op:operator pos:line="206" pos:column="81">.</op:operator><name pos:line="206" pos:column="82">Empty</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name pos:line="208" pos:column="13">var</name></type> <name pos:line="208" pos:column="17">nd</name> <init pos:line="208" pos:column="20">= <expr><op:operator pos:line="208" pos:column="22">new</op:operator> <name pos:line="208" pos:column="26">NamespaceDefinition</name> <block pos:line="208" pos:column="46">{
                <expr><name pos:line="209" pos:column="17">Name</name> <op:operator pos:line="209" pos:column="22">=</op:operator> <name pos:line="209" pos:column="24">namespaceName</name></expr>,
                <expr><name pos:line="210" pos:column="17">ProgrammingLanguage</name> <op:operator pos:line="210" pos:column="37">=</op:operator> <name pos:line="210" pos:column="39">ParserLanguage</name></expr>,
            }</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name pos:line="212" pos:column="13">nd</name><op:operator pos:line="212" pos:column="15">.</op:operator><name pos:line="212" pos:column="16">AddLocation</name></name><argument_list pos:line="212" pos:column="27">(<argument><expr><call><name><name pos:line="212" pos:column="28">context</name><op:operator pos:line="212" pos:column="35">.</op:operator><name pos:line="212" pos:column="36">CreateLocation</name></name><argument_list pos:line="212" pos:column="50">(<argument><expr><name pos:line="212" pos:column="51">namespaceElement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line" pos:line="214" pos:column="13">//add children</comment>
            <decl_stmt><decl><type><name pos:line="215" pos:column="13">var</name></type> <name pos:line="215" pos:column="17">blockElement</name> <init pos:line="215" pos:column="30">= <expr><call><name><name pos:line="215" pos:column="32">namespaceElement</name><op:operator pos:line="215" pos:column="48">.</op:operator><name pos:line="215" pos:column="49">Element</name></name><argument_list pos:line="215" pos:column="56">(<argument><expr><name><name pos:line="215" pos:column="57">SRC</name><op:operator pos:line="215" pos:column="60">.</op:operator><name pos:line="215" pos:column="61">Block</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if pos:line="216" pos:column="13">if<condition pos:line="216" pos:column="15">(<expr><name pos:line="216" pos:column="16">blockElement</name> <op:operator pos:line="216" pos:column="29">!=</op:operator> <name pos:line="216" pos:column="32">null</name></expr>)</condition><then pos:line="216" pos:column="37"> <block pos:line="216" pos:column="38">{
                <foreach pos:line="217" pos:column="17">foreach(<init><decl><type><name pos:line="217" pos:column="25">var</name></type> <name pos:line="217" pos:column="29">child</name> <range pos:line="217" pos:column="35">in <expr><call><name><name pos:line="217" pos:column="38">blockElement</name><op:operator pos:line="217" pos:column="50">.</op:operator><name pos:line="217" pos:column="51">Elements</name></name><argument_list pos:line="217" pos:column="59">()</argument_list></call></expr></range></decl></init>) <block pos:line="217" pos:column="63">{
                    <expr_stmt><expr><call><name><name pos:line="218" pos:column="21">nd</name><op:operator pos:line="218" pos:column="23">.</op:operator><name pos:line="218" pos:column="24">AddChildStatement</name></name><argument_list pos:line="218" pos:column="41">(<argument><expr><call><name pos:line="218" pos:column="42">ParseStatement</name><argument_list pos:line="218" pos:column="56">(<argument><expr><name pos:line="218" pos:column="57">child</name></expr></argument>, <argument><expr><name pos:line="218" pos:column="64">context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></foreach>
            }</block></then></if>

            <return pos:line="222" pos:column="13">return <expr><name pos:line="222" pos:column="20">nd</name></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="225" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="226" pos:column="9">/// Parses an element corresponding to a type definition and creates a TypeDefinition object </comment>
        <comment type="line" pos:line="227" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="228" pos:column="9">/// &lt;param name="typeElement"&gt;The type element to parse. This must be one of the elements contained in TypeElementNames.&lt;/param&gt;</comment>
        <comment type="line" pos:line="229" pos:column="9">/// &lt;param name="context"&gt;The parser context&lt;/param&gt;</comment>
        <comment type="line" pos:line="230" pos:column="9">/// &lt;returns&gt;A TypeDefinition parsed from the element&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="231" pos:column="9">protected</specifier> <specifier pos:line="231" pos:column="19">override</specifier> <name pos:line="231" pos:column="28">TypeDefinition</name></type> <name pos:line="231" pos:column="43">ParseTypeElement</name><parameter_list pos:line="231" pos:column="59">(<param><decl><type><name pos:line="231" pos:column="60">XElement</name></type> <name pos:line="231" pos:column="69">typeElement</name></decl></param>, <param><decl><type><name pos:line="231" pos:column="82">ParserContext</name></type> <name pos:line="231" pos:column="96">context</name></decl></param>)</parameter_list> <block pos:line="231" pos:column="105">{
            <if pos:line="232" pos:column="13">if<condition pos:line="232" pos:column="15">(<expr><name pos:line="232" pos:column="16">null</name> <op:operator pos:line="232" pos:column="21">==</op:operator> <name pos:line="232" pos:column="24">typeElement</name></expr>)</condition><then pos:line="232" pos:column="36">
                <throw pos:line="233" pos:column="17">throw <expr><op:operator pos:line="233" pos:column="23">new</op:operator> <call><name pos:line="233" pos:column="27">ArgumentNullException</name><argument_list pos:line="233" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="233" pos:column="49">"typeElement"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <if pos:line="234" pos:column="13">if<condition pos:line="234" pos:column="15">(<expr><name pos:line="234" pos:column="16">context</name> <op:operator pos:line="234" pos:column="24">==</op:operator> <name pos:line="234" pos:column="27">null</name></expr>)</condition><then pos:line="234" pos:column="32">
                <throw pos:line="235" pos:column="17">throw <expr><op:operator pos:line="235" pos:column="23">new</op:operator> <call><name pos:line="235" pos:column="27">ArgumentNullException</name><argument_list pos:line="235" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="235" pos:column="49">"context"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name pos:line="237" pos:column="13">var</name></type> <name pos:line="237" pos:column="17">typeDefinition</name> <init pos:line="237" pos:column="32">= <expr><op:operator pos:line="237" pos:column="34">new</op:operator> <call><name pos:line="237" pos:column="38">TypeDefinition</name><argument_list pos:line="237" pos:column="52">()</argument_list></call> <block pos:line="237" pos:column="55">{
                <expr><name pos:line="238" pos:column="17">Accessibility</name> <op:operator pos:line="238" pos:column="31">=</op:operator> <call><name pos:line="238" pos:column="33">GetAccessModifierForType</name><argument_list pos:line="238" pos:column="57">(<argument><expr><name pos:line="238" pos:column="58">typeElement</name></expr></argument>)</argument_list></call></expr>,
                <expr><name pos:line="239" pos:column="17">Kind</name> <op:operator pos:line="239" pos:column="22">=</op:operator> <call><name><name pos:line="239" pos:column="24">XNameMaps</name><op:operator pos:line="239" pos:column="33">.</op:operator><name pos:line="239" pos:column="34">GetKindForXElement</name></name><argument_list pos:line="239" pos:column="52">(<argument><expr><name pos:line="239" pos:column="53">typeElement</name></expr></argument>)</argument_list></call></expr>,
                <expr><name pos:line="240" pos:column="17">Name</name> <op:operator pos:line="240" pos:column="22">=</op:operator> <call><name pos:line="240" pos:column="24">GetNameForType</name><argument_list pos:line="240" pos:column="38">(<argument><expr><name pos:line="240" pos:column="39">typeElement</name></expr></argument>)</argument_list></call></expr>,
                <expr><name pos:line="241" pos:column="17">ProgrammingLanguage</name> <op:operator pos:line="241" pos:column="37">=</op:operator> <name pos:line="241" pos:column="39">ParserLanguage</name></expr>
            }</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name pos:line="243" pos:column="13">typeDefinition</name><op:operator pos:line="243" pos:column="27">.</op:operator><name pos:line="243" pos:column="28">AddLocation</name></name><argument_list pos:line="243" pos:column="39">(<argument><expr><call><name><name pos:line="243" pos:column="40">context</name><op:operator pos:line="243" pos:column="47">.</op:operator><name pos:line="243" pos:column="48">CreateLocation</name></name><argument_list pos:line="243" pos:column="62">(<argument><expr><name pos:line="243" pos:column="63">typeElement</name></expr></argument>, <argument><expr><call><name pos:line="243" pos:column="76">ContainerIsReference</name><argument_list pos:line="243" pos:column="96">(<argument><expr><name pos:line="243" pos:column="97">typeElement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <foreach pos:line="245" pos:column="13">foreach(<init><decl><type><name pos:line="245" pos:column="21">var</name></type> <name pos:line="245" pos:column="25">parentTypeElement</name> <range pos:line="245" pos:column="43">in <expr><call><name pos:line="245" pos:column="46">GetParentTypeUseElements</name><argument_list pos:line="245" pos:column="70">(<argument><expr><name pos:line="245" pos:column="71">typeElement</name></expr></argument>)</argument_list></call></expr></range></decl></init>) <block pos:line="245" pos:column="85">{
                <decl_stmt><decl><type><name pos:line="246" pos:column="17">var</name></type> <name pos:line="246" pos:column="21">parentTypeUse</name> <init pos:line="246" pos:column="35">= <expr><call><name pos:line="246" pos:column="37">ParseTypeUseElement</name><argument_list pos:line="246" pos:column="56">(<argument><expr><name pos:line="246" pos:column="57">parentTypeElement</name></expr></argument>, <argument><expr><name pos:line="246" pos:column="76">context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name pos:line="247" pos:column="17">typeDefinition</name><op:operator pos:line="247" pos:column="31">.</op:operator><name pos:line="247" pos:column="32">AddParentType</name></name><argument_list pos:line="247" pos:column="45">(<argument><expr><name pos:line="247" pos:column="46">parentTypeUse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></foreach>

            <decl_stmt><decl><type><name pos:line="250" pos:column="13">var</name></type> <name pos:line="250" pos:column="17">typeBlock</name> <init pos:line="250" pos:column="27">= <expr><call><name><name pos:line="250" pos:column="29">typeElement</name><op:operator pos:line="250" pos:column="40">.</op:operator><name pos:line="250" pos:column="41">Element</name></name><argument_list pos:line="250" pos:column="48">(<argument><expr><name><name pos:line="250" pos:column="49">SRC</name><op:operator pos:line="250" pos:column="52">.</op:operator><name pos:line="250" pos:column="53">Block</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if pos:line="251" pos:column="13">if<condition pos:line="251" pos:column="15">(<expr><name pos:line="251" pos:column="16">typeBlock</name> <op:operator pos:line="251" pos:column="26">!=</op:operator> <name pos:line="251" pos:column="29">null</name></expr>)</condition><then pos:line="251" pos:column="34"> <block pos:line="251" pos:column="35">{
                <foreach pos:line="252" pos:column="17">foreach(<init><decl><type><name pos:line="252" pos:column="25">var</name></type> <name pos:line="252" pos:column="29">child</name> <range pos:line="252" pos:column="35">in <expr><call><name><name pos:line="252" pos:column="38">typeBlock</name><op:operator pos:line="252" pos:column="47">.</op:operator><name pos:line="252" pos:column="48">Elements</name></name><argument_list pos:line="252" pos:column="56">()</argument_list></call></expr></range></decl></init>) <block pos:line="252" pos:column="60">{
                    <if pos:line="253" pos:column="21">if<condition pos:line="253" pos:column="23">(<expr><name><name pos:line="253" pos:column="24">child</name><op:operator pos:line="253" pos:column="29">.</op:operator><name pos:line="253" pos:column="30">Name</name></name> <op:operator pos:line="253" pos:column="35">==</op:operator> <name><name pos:line="253" pos:column="38">SRC</name><op:operator pos:line="253" pos:column="41">.</op:operator><name pos:line="253" pos:column="42">Private</name></name></expr>)</condition><then pos:line="253" pos:column="50"> <block pos:line="253" pos:column="51">{
                        <expr_stmt><expr><call><name><name pos:line="254" pos:column="25">typeDefinition</name><op:operator pos:line="254" pos:column="39">.</op:operator><name pos:line="254" pos:column="40">AddChildStatements</name></name><argument_list pos:line="254" pos:column="58">(<argument><expr><call><name pos:line="254" pos:column="59">ParseClassChildren</name><argument_list pos:line="254" pos:column="77">(<argument><expr><name pos:line="254" pos:column="78">child</name></expr></argument>, <argument><expr><name pos:line="254" pos:column="85">context</name></expr></argument>, <argument><expr><name><name pos:line="254" pos:column="94">AccessModifier</name><op:operator pos:line="254" pos:column="108">.</op:operator><name pos:line="254" pos:column="109">Private</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else pos:line="255" pos:column="23">else <if pos:line="255" pos:column="28">if<condition pos:line="255" pos:column="30">(<expr><name><name pos:line="255" pos:column="31">child</name><op:operator pos:line="255" pos:column="36">.</op:operator><name pos:line="255" pos:column="37">Name</name></name> <op:operator pos:line="255" pos:column="42">==</op:operator> <name><name pos:line="255" pos:column="45">SRC</name><op:operator pos:line="255" pos:column="48">.</op:operator><name pos:line="255" pos:column="49">Protected</name></name></expr>)</condition><then pos:line="255" pos:column="59"> <block pos:line="255" pos:column="60">{
                        <expr_stmt><expr><call><name><name pos:line="256" pos:column="25">typeDefinition</name><op:operator pos:line="256" pos:column="39">.</op:operator><name pos:line="256" pos:column="40">AddChildStatements</name></name><argument_list pos:line="256" pos:column="58">(<argument><expr><call><name pos:line="256" pos:column="59">ParseClassChildren</name><argument_list pos:line="256" pos:column="77">(<argument><expr><name pos:line="256" pos:column="78">child</name></expr></argument>, <argument><expr><name pos:line="256" pos:column="85">context</name></expr></argument>, <argument><expr><name><name pos:line="256" pos:column="94">AccessModifier</name><op:operator pos:line="256" pos:column="108">.</op:operator><name pos:line="256" pos:column="109">Protected</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else pos:line="257" pos:column="23">else <if pos:line="257" pos:column="28">if<condition pos:line="257" pos:column="30">(<expr><name><name pos:line="257" pos:column="31">child</name><op:operator pos:line="257" pos:column="36">.</op:operator><name pos:line="257" pos:column="37">Name</name></name> <op:operator pos:line="257" pos:column="42">==</op:operator> <name><name pos:line="257" pos:column="45">SRC</name><op:operator pos:line="257" pos:column="48">.</op:operator><name pos:line="257" pos:column="49">Public</name></name></expr>)</condition><then pos:line="257" pos:column="56"> <block pos:line="257" pos:column="57">{
                        <expr_stmt><expr><call><name><name pos:line="258" pos:column="25">typeDefinition</name><op:operator pos:line="258" pos:column="39">.</op:operator><name pos:line="258" pos:column="40">AddChildStatements</name></name><argument_list pos:line="258" pos:column="58">(<argument><expr><call><name pos:line="258" pos:column="59">ParseClassChildren</name><argument_list pos:line="258" pos:column="77">(<argument><expr><name pos:line="258" pos:column="78">child</name></expr></argument>, <argument><expr><name pos:line="258" pos:column="85">context</name></expr></argument>, <argument><expr><name><name pos:line="258" pos:column="94">AccessModifier</name><op:operator pos:line="258" pos:column="108">.</op:operator><name pos:line="258" pos:column="109">Public</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else pos:line="259" pos:column="23">else <block pos:line="259" pos:column="28">{
                        <expr_stmt><expr><call><name><name pos:line="260" pos:column="25">typeDefinition</name><op:operator pos:line="260" pos:column="39">.</op:operator><name pos:line="260" pos:column="40">AddChildStatement</name></name><argument_list pos:line="260" pos:column="57">(<argument><expr><call><name pos:line="260" pos:column="58">ParseStatement</name><argument_list pos:line="260" pos:column="72">(<argument><expr><name pos:line="260" pos:column="73">child</name></expr></argument>, <argument><expr><name pos:line="260" pos:column="80">context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if></else></if></else></if>
                }</block></foreach>
            }</block></then></if>


            <return pos:line="266" pos:column="13">return <expr><name pos:line="266" pos:column="20">typeDefinition</name></expr>;</return>
        }</block></function>

        <comment type="line" pos:line="269" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="270" pos:column="9">/// Parses the given &lt;paramref name="aliasElement"/&gt; and creates an ImportStatement or AliasStatement from it.</comment>
        <comment type="line" pos:line="271" pos:column="9">/// &lt;/summary&gt;</comment>
        <comment type="line" pos:line="272" pos:column="9">/// &lt;param name="aliasElement"&gt;The alias element to parse.&lt;/param&gt;</comment>
        <comment type="line" pos:line="273" pos:column="9">/// &lt;param name="context"&gt;The parser context to use.&lt;/param&gt;</comment>
        <comment type="line" pos:line="274" pos:column="9">/// &lt;returns&gt;An ImportStatement if the element is an import, or an AliasStatement if it is an alias.&lt;/returns&gt;</comment>
        <function><type><specifier pos:line="275" pos:column="9">protected</specifier> <specifier pos:line="275" pos:column="19">override</specifier> <name pos:line="275" pos:column="28">Statement</name></type> <name pos:line="275" pos:column="38">ParseAliasElement</name><parameter_list pos:line="275" pos:column="55">(<param><decl><type><name pos:line="275" pos:column="56">XElement</name></type> <name pos:line="275" pos:column="65">aliasElement</name></decl></param>, <param><decl><type><name pos:line="275" pos:column="79">ParserContext</name></type> <name pos:line="275" pos:column="93">context</name></decl></param>)</parameter_list> <block pos:line="275" pos:column="102">{
            <if pos:line="276" pos:column="13">if<condition pos:line="276" pos:column="15">(<expr><name pos:line="276" pos:column="16">null</name> <op:operator pos:line="276" pos:column="21">==</op:operator> <name pos:line="276" pos:column="24">aliasElement</name></expr>)</condition><then pos:line="276" pos:column="37">
                <throw pos:line="277" pos:column="17">throw <expr><op:operator pos:line="277" pos:column="23">new</op:operator> <call><name pos:line="277" pos:column="27">ArgumentNullException</name><argument_list pos:line="277" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="277" pos:column="49">"aliasElement"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <if pos:line="278" pos:column="13">if<condition pos:line="278" pos:column="15">(<expr><name><name pos:line="278" pos:column="16">aliasElement</name><op:operator pos:line="278" pos:column="28">.</op:operator><name pos:line="278" pos:column="29">Name</name></name> <op:operator pos:line="278" pos:column="34">!=</op:operator> <name pos:line="278" pos:column="37">AliasElementName</name></expr>)</condition><then pos:line="278" pos:column="54">
                <throw pos:line="279" pos:column="17">throw <expr><op:operator pos:line="279" pos:column="23">new</op:operator> <call><name pos:line="279" pos:column="27">ArgumentException</name><argument_list pos:line="279" pos:column="44">(<argument><expr><call><name><name pos:line="279" pos:column="45">string</name><op:operator pos:line="279" pos:column="51">.</op:operator><name pos:line="279" pos:column="52">Format</name></name><argument_list pos:line="279" pos:column="58">(<argument><expr><lit:literal type="string" pos:line="279" pos:column="59">"Must be a SRC.{0} element"</lit:literal></expr></argument>, <argument><expr><name><name pos:line="279" pos:column="88">AliasElementName</name><op:operator pos:line="279" pos:column="104">.</op:operator><name pos:line="279" pos:column="105">LocalName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lit:literal type="string" pos:line="279" pos:column="117">"aliasElement"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <if pos:line="280" pos:column="13">if<condition pos:line="280" pos:column="15">(<expr><name pos:line="280" pos:column="16">context</name> <op:operator pos:line="280" pos:column="24">==</op:operator> <name pos:line="280" pos:column="27">null</name></expr>)</condition><then pos:line="280" pos:column="32">
                <throw pos:line="281" pos:column="17">throw <expr><op:operator pos:line="281" pos:column="23">new</op:operator> <call><name pos:line="281" pos:column="27">ArgumentNullException</name><argument_list pos:line="281" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="281" pos:column="49">"context"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name pos:line="283" pos:column="13">Statement</name></type> <name pos:line="283" pos:column="23">stmt</name> <init pos:line="283" pos:column="28">= <expr><name pos:line="283" pos:column="30">null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name pos:line="284" pos:column="13">bool</name></type> <name pos:line="284" pos:column="18">containsNamespaceKeyword</name> <init pos:line="284" pos:column="43">= <expr><op:operator pos:line="284" pos:column="45">(</op:operator><linq><from pos:line="284" pos:column="46">from <expr><name pos:line="284" pos:column="51">textNode</name></expr> <in pos:line="284" pos:column="60">in <expr><call><name pos:line="284" pos:column="63">GetTextNodes</name><argument_list pos:line="284" pos:column="75">(<argument><expr><name pos:line="284" pos:column="76">aliasElement</name></expr></argument>)</argument_list></call></expr></in></from>
                                             <where pos:line="285" pos:column="46">where <expr><call><name><name pos:line="285" pos:column="52">textNode</name><op:operator pos:line="285" pos:column="60">.</op:operator><name pos:line="285" pos:column="61">Value</name><op:operator pos:line="285" pos:column="66">.</op:operator><name pos:line="285" pos:column="67">Contains</name></name><argument_list pos:line="285" pos:column="75">(<argument><expr><lit:literal type="string" pos:line="285" pos:column="76">"namespace"</lit:literal></expr></argument>)</argument_list></call></expr></where>
                                             <select pos:line="286" pos:column="46">select <expr><name pos:line="286" pos:column="53">textNode</name></expr></select></linq><op:operator pos:line="286" pos:column="61">)</op:operator><op:operator pos:line="286" pos:column="62">.</op:operator><call><name pos:line="286" pos:column="63">Any</name><argument_list pos:line="286" pos:column="66">()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if pos:line="287" pos:column="13">if<condition pos:line="287" pos:column="15">(<expr><name pos:line="287" pos:column="16">containsNamespaceKeyword</name></expr>)</condition><then pos:line="287" pos:column="41"> <block pos:line="287" pos:column="42">{
                <comment type="line" pos:line="288" pos:column="17">//import statement</comment>
                <decl_stmt><decl><type><name pos:line="289" pos:column="17">var</name></type> <name pos:line="289" pos:column="21">import</name> <init pos:line="289" pos:column="28">= <expr><op:operator pos:line="289" pos:column="30">new</op:operator> <call><name pos:line="289" pos:column="34">ImportStatement</name><argument_list pos:line="289" pos:column="49">()</argument_list></call> <block pos:line="289" pos:column="52">{<expr><name pos:line="289" pos:column="53">ProgrammingLanguage</name> <op:operator pos:line="289" pos:column="73">=</op:operator> <name pos:line="289" pos:column="75">ParserLanguage</name></expr>}</block></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name pos:line="290" pos:column="17">import</name><op:operator pos:line="290" pos:column="23">.</op:operator><name pos:line="290" pos:column="24">AddLocation</name></name><argument_list pos:line="290" pos:column="35">(<argument><expr><call><name><name pos:line="290" pos:column="36">context</name><op:operator pos:line="290" pos:column="43">.</op:operator><name pos:line="290" pos:column="44">CreateLocation</name></name><argument_list pos:line="290" pos:column="58">(<argument><expr><name pos:line="290" pos:column="59">aliasElement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name pos:line="292" pos:column="17">var</name></type> <name pos:line="292" pos:column="21">nameElement</name> <init pos:line="292" pos:column="33">= <expr><call><name><name pos:line="292" pos:column="35">aliasElement</name><op:operator pos:line="292" pos:column="47">.</op:operator><name pos:line="292" pos:column="48">Element</name></name><argument_list pos:line="292" pos:column="55">(<argument><expr><name><name pos:line="292" pos:column="56">SRC</name><op:operator pos:line="292" pos:column="59">.</op:operator><name pos:line="292" pos:column="60">Name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if pos:line="293" pos:column="17">if<condition pos:line="293" pos:column="19">(<expr><name pos:line="293" pos:column="20">nameElement</name> <op:operator pos:line="293" pos:column="32">!=</op:operator> <name pos:line="293" pos:column="35">null</name></expr>)</condition><then pos:line="293" pos:column="40"> <block pos:line="293" pos:column="41">{
                    <expr_stmt><expr><name><name pos:line="294" pos:column="21">import</name><op:operator pos:line="294" pos:column="27">.</op:operator><name pos:line="294" pos:column="28">ImportedNamespace</name></name> <op:operator pos:line="294" pos:column="46">=</op:operator> <call><name><name pos:line="294" pos:column="48">ParseNameUseElement</name><argument_list pos:line="294" pos:column="67">&lt;<argument><name pos:line="294" pos:column="68">NamespaceUse</name></argument>&gt;</argument_list></name><argument_list pos:line="294" pos:column="81">(<argument><expr><name pos:line="294" pos:column="82">nameElement</name></expr></argument>, <argument><expr><name pos:line="294" pos:column="95">context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <expr_stmt><expr><name pos:line="297" pos:column="17">stmt</name> <op:operator pos:line="297" pos:column="22">=</op:operator> <name pos:line="297" pos:column="24">import</name></expr>;</expr_stmt>
            }</block></then> <else pos:line="298" pos:column="15">else <block pos:line="298" pos:column="20">{
                <comment type="line" pos:line="299" pos:column="17">//alias statement</comment>
                <decl_stmt><decl><type><name pos:line="300" pos:column="17">var</name></type> <name pos:line="300" pos:column="21">alias</name> <init pos:line="300" pos:column="27">= <expr><op:operator pos:line="300" pos:column="29">new</op:operator> <call><name pos:line="300" pos:column="33">AliasStatement</name><argument_list pos:line="300" pos:column="47">()</argument_list></call> <block pos:line="300" pos:column="50">{<expr><name pos:line="300" pos:column="51">ProgrammingLanguage</name> <op:operator pos:line="300" pos:column="71">=</op:operator> <name pos:line="300" pos:column="73">ParserLanguage</name></expr>}</block></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name pos:line="301" pos:column="17">alias</name><op:operator pos:line="301" pos:column="22">.</op:operator><name pos:line="301" pos:column="23">AddLocation</name></name><argument_list pos:line="301" pos:column="34">(<argument><expr><call><name><name pos:line="301" pos:column="35">context</name><op:operator pos:line="301" pos:column="42">.</op:operator><name pos:line="301" pos:column="43">CreateLocation</name></name><argument_list pos:line="301" pos:column="57">(<argument><expr><name pos:line="301" pos:column="58">aliasElement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name pos:line="303" pos:column="17">var</name></type> <name pos:line="303" pos:column="21">nameElement</name> <init pos:line="303" pos:column="33">= <expr><call><name><name pos:line="303" pos:column="35">aliasElement</name><op:operator pos:line="303" pos:column="47">.</op:operator><name pos:line="303" pos:column="48">Element</name></name><argument_list pos:line="303" pos:column="55">(<argument><expr><name><name pos:line="303" pos:column="56">SRC</name><op:operator pos:line="303" pos:column="59">.</op:operator><name pos:line="303" pos:column="60">Name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name pos:line="304" pos:column="17">var</name></type> <name pos:line="304" pos:column="21">initElement</name> <init pos:line="304" pos:column="33">= <expr><call><name><name pos:line="304" pos:column="35">aliasElement</name><op:operator pos:line="304" pos:column="47">.</op:operator><name pos:line="304" pos:column="48">Element</name></name><argument_list pos:line="304" pos:column="55">(<argument><expr><name><name pos:line="304" pos:column="56">SRC</name><op:operator pos:line="304" pos:column="59">.</op:operator><name pos:line="304" pos:column="60">Init</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if pos:line="305" pos:column="17">if<condition pos:line="305" pos:column="19">(<expr><name pos:line="305" pos:column="20">initElement</name> <op:operator pos:line="305" pos:column="32">!=</op:operator> <name pos:line="305" pos:column="35">null</name></expr>)</condition><then pos:line="305" pos:column="40"> <block pos:line="305" pos:column="41">{
                    <comment type="line" pos:line="306" pos:column="21">//example: using foo = std::bar;</comment>
                    <if pos:line="307" pos:column="21">if<condition pos:line="307" pos:column="23">(<expr><name pos:line="307" pos:column="24">nameElement</name> <op:operator pos:line="307" pos:column="36">!=</op:operator> <name pos:line="307" pos:column="39">null</name></expr>)</condition><then pos:line="307" pos:column="44"> <block pos:line="307" pos:column="45">{
                        <expr_stmt><expr><name><name pos:line="308" pos:column="25">alias</name><op:operator pos:line="308" pos:column="30">.</op:operator><name pos:line="308" pos:column="31">AliasName</name></name> <op:operator pos:line="308" pos:column="41">=</op:operator> <name><name pos:line="308" pos:column="43">nameElement</name><op:operator pos:line="308" pos:column="54">.</op:operator><name pos:line="308" pos:column="55">Value</name></name></expr>;</expr_stmt>
                    }</block></then></if>
                    <comment type="line" pos:line="310" pos:column="21">//TODO check this once srcml is updated to see if it's accurate</comment>
                    <expr_stmt><expr><name><name pos:line="311" pos:column="21">alias</name><op:operator pos:line="311" pos:column="26">.</op:operator><name pos:line="311" pos:column="27">Target</name></name> <op:operator pos:line="311" pos:column="34">=</op:operator> <call><name pos:line="311" pos:column="36">ParseExpression</name><argument_list pos:line="311" pos:column="51">(<argument><expr><call><name pos:line="311" pos:column="52">GetFirstChildExpression</name><argument_list pos:line="311" pos:column="75">(<argument><expr><name pos:line="311" pos:column="76">initElement</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name pos:line="311" pos:column="90">context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else pos:line="312" pos:column="19">else <block pos:line="312" pos:column="24">{
                    <comment type="line" pos:line="313" pos:column="21">//example: using std::cout;</comment>
                    <if pos:line="314" pos:column="21">if<condition pos:line="314" pos:column="23">(<expr><name pos:line="314" pos:column="24">nameElement</name> <op:operator pos:line="314" pos:column="36">!=</op:operator> <name pos:line="314" pos:column="39">null</name></expr>)</condition><then pos:line="314" pos:column="44"> <block pos:line="314" pos:column="45">{
                        <expr_stmt><expr><name><name pos:line="315" pos:column="25">alias</name><op:operator pos:line="315" pos:column="30">.</op:operator><name pos:line="315" pos:column="31">Target</name></name> <op:operator pos:line="315" pos:column="38">=</op:operator> <call><name pos:line="315" pos:column="40">ParseTypeUseElement</name><argument_list pos:line="315" pos:column="59">(<argument><expr><name pos:line="315" pos:column="60">nameElement</name></expr></argument>, <argument><expr><name pos:line="315" pos:column="73">context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name pos:line="316" pos:column="25">alias</name><op:operator pos:line="316" pos:column="30">.</op:operator><name pos:line="316" pos:column="31">AliasName</name></name> <op:operator pos:line="316" pos:column="41">=</op:operator> <call><name><name pos:line="316" pos:column="43">NameHelper</name><op:operator pos:line="316" pos:column="53">.</op:operator><name pos:line="316" pos:column="54">GetLastName</name></name><argument_list pos:line="316" pos:column="65">(<argument><expr><name pos:line="316" pos:column="66">nameElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>

                <expr_stmt><expr><name pos:line="320" pos:column="17">stmt</name> <op:operator pos:line="320" pos:column="22">=</op:operator> <name pos:line="320" pos:column="24">alias</name></expr>;</expr_stmt>
            }</block></else></if>

            <return pos:line="323" pos:column="13">return <expr><name pos:line="323" pos:column="20">stmt</name></expr>;</return>
        }</block></function>

        <cpp:region pos:line="326" pos:column="9">#<cpp:directive pos:line="326" pos:column="10">region</cpp:directive> Private methods</cpp:region>
        <comment type="line" pos:line="327" pos:column="9">/// &lt;summary&gt;</comment>
        <comment type="line" pos:line="328" pos:column="9">/// This method parses and returns the children within the public/protected/private block under a C++ class, </comment>
        <comment type="line" pos:line="329" pos:column="9">/// and sets the specified access modifier on the children that support it.</comment>
        <comment type="line" pos:line="330" pos:column="9">/// &lt;/summary&gt;</comment>
        <function><type><specifier pos:line="331" pos:column="9">private</specifier> <name><name pos:line="331" pos:column="17">IEnumerable</name><argument_list pos:line="331" pos:column="28">&lt;<argument><name pos:line="331" pos:column="29">Statement</name></argument>&gt;</argument_list></name></type> <name pos:line="331" pos:column="40">ParseClassChildren</name><parameter_list pos:line="331" pos:column="58">(<param><decl><type><name pos:line="331" pos:column="59">XElement</name></type> <name pos:line="331" pos:column="68">accessBlockElement</name></decl></param>, <param><decl><type><name pos:line="331" pos:column="88">ParserContext</name></type> <name pos:line="331" pos:column="102">context</name></decl></param>, <param><decl><type><name pos:line="331" pos:column="111">AccessModifier</name></type> <name pos:line="331" pos:column="126">accessModifier</name></decl></param>)</parameter_list> <block pos:line="331" pos:column="142">{
            <if pos:line="332" pos:column="13">if<condition pos:line="332" pos:column="15">(<expr><name pos:line="332" pos:column="16">accessBlockElement</name> <op:operator pos:line="332" pos:column="35">==</op:operator> <name pos:line="332" pos:column="38">null</name></expr>)</condition><then pos:line="332" pos:column="43">
                <throw pos:line="333" pos:column="17">throw <expr><op:operator pos:line="333" pos:column="23">new</op:operator> <call><name pos:line="333" pos:column="27">ArgumentNullException</name><argument_list pos:line="333" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="333" pos:column="49">"accessBlockElement"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <if pos:line="334" pos:column="13">if<condition pos:line="334" pos:column="15">(<expr><op:operator pos:line="334" pos:column="16">!</op:operator><op:operator pos:line="334" pos:column="17">(</op:operator><op:operator pos:line="334" pos:column="18">new</op:operator><index pos:line="334" pos:column="21">[]</index></expr></condition><then pos:line="334" pos:column="23"> <block pos:line="334" pos:column="24">{<expr_stmt><expr><name><name pos:line="334" pos:column="25">SRC</name><op:operator pos:line="334" pos:column="28">.</op:operator><name pos:line="334" pos:column="29">Public</name></name></expr><op:operator pos:line="334" pos:column="35">,</op:operator> <expr><name><name pos:line="334" pos:column="37">SRC</name><op:operator pos:line="334" pos:column="40">.</op:operator><name pos:line="334" pos:column="41">Protected</name></name></expr><op:operator pos:line="334" pos:column="50">,</op:operator> <expr><name><name pos:line="334" pos:column="52">SRC</name><op:operator pos:line="334" pos:column="55">.</op:operator><name pos:line="334" pos:column="56">Private</name></name></expr></expr_stmt>}</block></then></if><expr_stmt><expr><op:operator pos:line="334" pos:column="64">.</op:operator><call><name pos:line="334" pos:column="65">Contains</name><argument_list pos:line="334" pos:column="73">(<argument><expr><name><name pos:line="334" pos:column="74">accessBlockElement</name><op:operator pos:line="334" pos:column="92">.</op:operator><name pos:line="334" pos:column="93">Name</name></name></expr></argument>)</argument_list></call></expr></expr_stmt>)</block></function>)</block>
                <throw pos:line="335" pos:column="17">throw <expr><op:operator pos:line="335" pos:column="23">new</op:operator> <call><name pos:line="335" pos:column="27">ArgumentException</name><argument_list pos:line="335" pos:column="44">(<argument><expr><lit:literal type="string" pos:line="335" pos:column="45">"Not a valid accessibility block element"</lit:literal></expr></argument>, <argument><expr><lit:literal type="string" pos:line="335" pos:column="88">"accessBlockElement"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></class>
            <if pos:line="336" pos:column="13">if<condition pos:line="336" pos:column="15">(<expr><name pos:line="336" pos:column="16">context</name> <op:operator pos:line="336" pos:column="24">==</op:operator> <name pos:line="336" pos:column="27">null</name></expr>)</condition><then pos:line="336" pos:column="32">
                <throw pos:line="337" pos:column="17">throw <expr><op:operator pos:line="337" pos:column="23">new</op:operator> <call><name pos:line="337" pos:column="27">ArgumentNullException</name><argument_list pos:line="337" pos:column="48">(<argument><expr><lit:literal type="string" pos:line="337" pos:column="49">"context"</lit:literal></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name pos:line="339" pos:column="13">var</name></type> <name pos:line="339" pos:column="17">children</name> <init pos:line="339" pos:column="26">= <expr><call><name><name pos:line="339" pos:column="28">accessBlockElement</name><op:operator pos:line="339" pos:column="46">.</op:operator><name pos:line="339" pos:column="47">Elements</name></name><argument_list pos:line="339" pos:column="55">()</argument_list></call><op:operator pos:line="339" pos:column="57">.</op:operator><call><name pos:line="339" pos:column="58">Select</name><argument_list pos:line="339" pos:column="64">(<argument><expr><lambda><name pos:line="339" pos:column="65">e</name> <op:operator pos:line="339" pos:column="67">=&gt;</op:operator> <call><name pos:line="339" pos:column="70">ParseStatement</name><argument_list pos:line="339" pos:column="84">(<argument><expr><name pos:line="339" pos:column="85">e</name></expr></argument>, <argument><expr><name pos:line="339" pos:column="88">context</name></expr></argument>)</argument_list></call></lambda></expr></argument>)</argument_list></call><op:operator pos:line="339" pos:column="97">.</op:operator><call><name pos:line="339" pos:column="98">ToList</name><argument_list pos:line="339" pos:column="104">()</argument_list></call></expr></init></decl>;</decl_stmt>
            <foreach pos:line="340" pos:column="13">foreach(<init><decl><type><name pos:line="340" pos:column="21">var</name></type> <name pos:line="340" pos:column="25">ne</name> <range pos:line="340" pos:column="28">in <expr><call><name><name pos:line="340" pos:column="31">children</name><op:operator pos:line="340" pos:column="39">.</op:operator><name><name pos:line="340" pos:column="40">OfType</name><argument_list pos:line="340" pos:column="46">&lt;<argument><name pos:line="340" pos:column="47">INamedEntity</name></argument>&gt;</argument_list></name></name><argument_list pos:line="340" pos:column="60">()</argument_list></call></expr></range></decl></init>) <block pos:line="340" pos:column="64">{
                <expr_stmt><expr><name><name pos:line="341" pos:column="17">ne</name><op:operator pos:line="341" pos:column="19">.</op:operator><name pos:line="341" pos:column="20">Accessibility</name></name> <op:operator pos:line="341" pos:column="34">=</op:operator> <name pos:line="341" pos:column="36">accessModifier</name></expr>;</expr_stmt>
            }</block></foreach>
            <return pos:line="343" pos:column="13">return <expr><name pos:line="343" pos:column="20">children</name></expr>;</return>
        }</block></namespace>

        <cpp:endregion pos:line="346" pos:column="9">#<cpp:directive pos:line="346" pos:column="10">endregion</cpp:directive> Private methods</cpp:endregion>
    }
}</unit>

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" xmlns:lit="http://www.sdml.info/srcML/literal" xmlns:op="http://www.sdml.info/srcML/operator" xmlns:type="http://www.sdml.info/srcML/modifier" xmlns:pos="http://www.sdml.info/srcML/position" language="C++" filename="D:\Research\Subjects\Sando-master\LIBS\Extensions\inc\office10\msoci.h" pos:tabs="8"><cpp:pragma pos:line="1" pos:column="1">#<cpp:directive pos:line="1" pos:column="2">pragma</cpp:directive> once</cpp:pragma>

<comment type="block" format="doxygen" pos:line="3" pos:column="1">/****************************************************************************
	MsoCI.h

	Owner: ClarG
 	Copyright (c) 1995 Microsoft Corporation

	This file contains the exported interfaces and declarations for
	Office Component Integration.
****************************************************************************/</comment>

<cpp:ifndef pos:line="13" pos:column="1">#<cpp:directive pos:line="13" pos:column="2">ifndef</cpp:directive> <name pos:line="13" pos:column="9">MSOCI_H</name></cpp:ifndef>
<cpp:define pos:line="14" pos:column="1">#<cpp:directive pos:line="14" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="14" pos:column="9">MSOCI_H</name></cpp:macro></cpp:define>

<cpp:if pos:line="16" pos:column="1">#<cpp:directive pos:line="16" pos:column="2">if</cpp:directive> <expr><op:operator pos:line="16" pos:column="5">!</op:operator><call><name pos:line="16" pos:column="6">defined</name><argument_list pos:line="16" pos:column="13">(<argument><expr><name pos:line="16" pos:column="14">MSOSTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include pos:line="17" pos:column="1">#<cpp:directive pos:line="17" pos:column="2">include</cpp:directive> <cpp:file pos:line="17" pos:column="10">&lt;msostd.h&gt;</cpp:file></cpp:include>
<cpp:endif pos:line="18" pos:column="1">#<cpp:directive pos:line="18" pos:column="2">endif</cpp:directive></cpp:endif>

<cpp:if pos:line="20" pos:column="1">#<cpp:directive pos:line="20" pos:column="2">if</cpp:directive> <expr><op:operator pos:line="20" pos:column="5">!</op:operator><call><name pos:line="20" pos:column="6">defined</name><argument_list pos:line="20" pos:column="13">(<argument><expr><name pos:line="20" pos:column="14">MSOUSER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include pos:line="21" pos:column="1">#<cpp:directive pos:line="21" pos:column="2">include</cpp:directive> <cpp:file pos:line="21" pos:column="10">&lt;msouser.h&gt;</cpp:file></cpp:include>
<cpp:endif pos:line="22" pos:column="1">#<cpp:directive pos:line="22" pos:column="2">endif</cpp:directive></cpp:endif>

<cpp:if pos:line="24" pos:column="1">#<cpp:directive pos:line="24" pos:column="2">if</cpp:directive> <expr><op:operator pos:line="24" pos:column="5">!</op:operator><call><name pos:line="24" pos:column="6">defined</name><argument_list pos:line="24" pos:column="13">(<argument><expr><name pos:line="24" pos:column="14">MSODEBUG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include pos:line="25" pos:column="1">#<cpp:directive pos:line="25" pos:column="2">include</cpp:directive> <cpp:file pos:line="25" pos:column="10">&lt;msodebug.h&gt;</cpp:file></cpp:include>
<cpp:endif pos:line="26" pos:column="1">#<cpp:directive pos:line="26" pos:column="2">endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen" pos:line="28" pos:column="1">/****************************************************************************
	Component integration structures and constants
****************************************************************************/</comment>

<comment type="line" pos:line="32" pos:column="1">// Component registration flags</comment>
<enum pos:line="33" pos:column="1">enum
	<block pos:line="34" pos:column="9">{
	<decl><name pos:line="35" pos:column="9">msocrfNeedIdleTime</name>         <init pos:line="35" pos:column="36">= <expr><lit:literal type="number" pos:line="35" pos:column="38">1</lit:literal></expr></init></decl><op:operator pos:line="35" pos:column="39">,</op:operator>  <comment type="line" pos:line="35" pos:column="42">// needs idle time</comment>
	<decl><name pos:line="36" pos:column="9">msocrfNeedPeriodicIdleTime</name> <init pos:line="36" pos:column="36">= <expr><lit:literal type="number" pos:line="36" pos:column="38">2</lit:literal></expr></init></decl><op:operator pos:line="36" pos:column="39">,</op:operator>  <comment type="line" pos:line="36" pos:column="42">// needs idle time every N milliseconds</comment>
	<decl><name pos:line="37" pos:column="9">msocrfPreTranslateKeys</name>     <init pos:line="37" pos:column="36">= <expr><lit:literal type="number" pos:line="37" pos:column="38">4</lit:literal></expr></init></decl><op:operator pos:line="37" pos:column="39">,</op:operator>  <comment type="line" pos:line="37" pos:column="42">// must process keyboard msgs</comment>
	                                 <comment type="line" pos:line="38" pos:column="42">// before translation</comment>
	<decl><name pos:line="39" pos:column="9">msocrfPreTranslateAll</name>      <init pos:line="39" pos:column="36">= <expr><lit:literal type="number" pos:line="39" pos:column="38">8</lit:literal></expr></init></decl><op:operator pos:line="39" pos:column="39">,</op:operator>  <comment type="line" pos:line="39" pos:column="42">// must process all msgs</comment>
	                                 <comment type="line" pos:line="40" pos:column="42">// before translation</comment>
	<decl><name pos:line="41" pos:column="9">msocrfNeedSpecActiveNotifs</name> <init pos:line="41" pos:column="36">= <expr><lit:literal type="number" pos:line="41" pos:column="38">16</lit:literal></expr></init></decl><op:operator pos:line="41" pos:column="40">,</op:operator> <comment type="line" pos:line="41" pos:column="42">// needs to be notified for special</comment>
	                                 <comment type="line" pos:line="42" pos:column="42">// activation changes (currently, this will</comment>
	                                 <comment type="line" pos:line="43" pos:column="42">// notify comp if ExclusiveBorderSpace</comment>
	                                 <comment type="line" pos:line="44" pos:column="42">// or ExclusiveActivation mode changes)</comment>
	                                 <comment type="line" pos:line="45" pos:column="42">// Top-level comps should reg this flag.</comment>
	<decl><name pos:line="46" pos:column="9">msocrfNeedTopActiveNotifs</name>  <init pos:line="46" pos:column="36">= <expr><name pos:line="46" pos:column="38">msocrfNeedSpecActiveNotifs</name></expr></init></decl><op:operator pos:line="46" pos:column="64">,</op:operator> <comment type="line" pos:line="46" pos:column="66">// old name</comment>
	<decl><name pos:line="47" pos:column="9">msocrfNeedAllActiveNotifs</name>  <init pos:line="47" pos:column="36">= <expr><lit:literal type="number" pos:line="47" pos:column="38">32</lit:literal></expr></init></decl><op:operator pos:line="47" pos:column="40">,</op:operator> <comment type="line" pos:line="47" pos:column="42">// needs to be notified for every</comment>
	                                 <comment type="line" pos:line="48" pos:column="42">// change in activation state</comment>
	<decl><name pos:line="49" pos:column="9">msocrfExclusiveBorderSpace</name> <init pos:line="49" pos:column="36">= <expr><lit:literal type="number" pos:line="49" pos:column="38">64</lit:literal></expr></init></decl><op:operator pos:line="49" pos:column="40">,</op:operator> <comment type="line" pos:line="49" pos:column="42">// needs exclusive border space when </comment>
	                                 <comment type="line" pos:line="50" pos:column="42">// active (normally only used by TopLevel</comment>
	                                 <comment type="line" pos:line="51" pos:column="42">// Mac components)</comment>
	<decl><name pos:line="52" pos:column="9">msocrfExclusiveActivation</name> <init pos:line="52" pos:column="35">= <expr><lit:literal type="number" pos:line="52" pos:column="37">128</lit:literal></expr></init></decl><op:operator pos:line="52" pos:column="40">,</op:operator> <comment type="line" pos:line="52" pos:column="42">// comp becomes exclusively active </comment>
	                                 <comment type="line" pos:line="53" pos:column="42">// when activated</comment>
	<decl><name pos:line="54" pos:column="9">msocrfNeedAllMacEvents</name>	<init pos:line="54" pos:column="33">= <expr><lit:literal type="number" pos:line="54" pos:column="35">256</lit:literal></expr></init></decl><op:operator pos:line="54" pos:column="38">,</op:operator>	 <comment type="line" pos:line="54" pos:column="42">// needs all mac events</comment>
	<decl><name pos:line="55" pos:column="9">msocrfMaster</name>			<init pos:line="55" pos:column="41">= <expr><lit:literal type="number" pos:line="55" pos:column="43">512</lit:literal></expr></init></decl><op:operator pos:line="55" pos:column="46">,</op:operator>   <comment type="line" pos:line="55" pos:column="50">// comp is always active and gets first shot at evrything</comment>
	}</block>;</enum>

<comment type="line" pos:line="58" pos:column="1">// Component registration advise flags (see msocstate enumeration)</comment>
<enum pos:line="59" pos:column="1">enum
	<block pos:line="60" pos:column="9">{
	<decl><name pos:line="61" pos:column="9">msocadvfModal</name>              <init pos:line="61" pos:column="36">= <expr><lit:literal type="number" pos:line="61" pos:column="38">1</lit:literal></expr></init></decl><op:operator pos:line="61" pos:column="39">,</op:operator>  <comment type="line" pos:line="61" pos:column="42">// needs modal state change notification</comment>
	                                 <comment type="line" pos:line="62" pos:column="42">//  (must be registered by components</comment>
	                                 <comment type="line" pos:line="63" pos:column="42">//   managing a toplevel window)												</comment>
	<decl><name pos:line="64" pos:column="9">msocadvfRedrawOff</name>          <init pos:line="64" pos:column="36">= <expr><lit:literal type="number" pos:line="64" pos:column="38">2</lit:literal></expr></init></decl><op:operator pos:line="64" pos:column="39">,</op:operator>  <comment type="line" pos:line="64" pos:column="42">// needs redrawOff state change notif</comment>
	<decl><name pos:line="65" pos:column="9">msocadvfWarningsOff</name>        <init pos:line="65" pos:column="36">= <expr><lit:literal type="number" pos:line="65" pos:column="38">4</lit:literal></expr></init></decl><op:operator pos:line="65" pos:column="39">,</op:operator>  <comment type="line" pos:line="65" pos:column="42">// needs warningsOff state change notif</comment>
	<decl><name pos:line="66" pos:column="9">msocadvfRecording</name>          <init pos:line="66" pos:column="36">= <expr><lit:literal type="number" pos:line="66" pos:column="38">8</lit:literal></expr></init></decl><op:operator pos:line="66" pos:column="39">,</op:operator>  <comment type="line" pos:line="66" pos:column="42">// needs Recording state change notif</comment>
	}</block>;</enum>

<comment type="line" pos:line="69" pos:column="1">// Component registration information</comment>
<typedef pos:line="70" pos:column="1">typedef <type><struct pos:line="70" pos:column="9">struct <name pos:line="70" pos:column="16">_MSOCRINFO</name>
	<block pos:line="71" pos:column="9">{<public type="default" pos:line="71" pos:column="10">
	<decl_stmt><decl><type><name pos:line="72" pos:column="9">ULONG</name></type> <name pos:line="72" pos:column="15">cbSize</name></decl>;</decl_stmt>             <comment type="line" pos:line="72" pos:column="35">// size of MSOCRINFO structure in bytes.</comment>
	<decl_stmt><decl><type><name pos:line="73" pos:column="9">ULONG</name></type> <name pos:line="73" pos:column="15">uIdleTimeInterval</name></decl>;</decl_stmt>  <comment type="line" pos:line="73" pos:column="35">// If msocrfNeedPeriodicIdleTime is registered</comment>
	                          <comment type="line" pos:line="74" pos:column="35">// in grfcrf, component needs to perform</comment>
	                          <comment type="line" pos:line="75" pos:column="35">// periodic idle time tasks during an idle phase</comment>
	                          <comment type="line" pos:line="76" pos:column="35">// every uIdleTimeInterval milliseconds.</comment>
	<decl_stmt><decl><type><name pos:line="77" pos:column="9">DWORD</name></type> <name pos:line="77" pos:column="15">grfcrf</name></decl>;</decl_stmt>             <comment type="line" pos:line="77" pos:column="35">// bit flags taken from msocrf values (above)</comment>
	<decl_stmt><decl><type><name pos:line="78" pos:column="9">DWORD</name></type> <name pos:line="78" pos:column="15">grfcadvf</name></decl>;</decl_stmt>           <comment type="line" pos:line="78" pos:column="35">// bit flags taken from msocadvf values (above)</comment>
	</public>}</block></struct></type> <name pos:line="79" pos:column="11">MSOCRINFO</name>;</typedef>


<comment type="line" pos:line="82" pos:column="1">// Component Host flags</comment>
<enum pos:line="83" pos:column="1">enum
	<block pos:line="84" pos:column="9">{
	<decl><name pos:line="85" pos:column="9">msochostfExclusiveBorderSpace</name> <init pos:line="85" pos:column="39">= <expr><lit:literal type="number" pos:line="85" pos:column="41">1</lit:literal></expr></init></decl><op:operator pos:line="85" pos:column="42">,</op:operator>  <comment type="line" pos:line="85" pos:column="45">// needs exclusive border space when </comment>
	                                    <comment type="line" pos:line="86" pos:column="45">// active (normally only used by </comment>
	                                    <comment type="line" pos:line="87" pos:column="45">// TopLevel Mac hosts)</comment>
	}</block>;</enum>

<comment type="line" pos:line="90" pos:column="1">// Component Host information</comment>
<typedef pos:line="91" pos:column="1">typedef <type><struct pos:line="91" pos:column="9">struct <name pos:line="91" pos:column="16">_MSOCHOSTINFO</name>
	<block pos:line="92" pos:column="9">{<public type="default" pos:line="92" pos:column="10">
	<decl_stmt><decl><type><name pos:line="93" pos:column="9">ULONG</name></type> <name pos:line="93" pos:column="15">cbSize</name></decl>;</decl_stmt>             <comment type="line" pos:line="93" pos:column="35">// size of MSOCHOSTINFO structure in bytes.</comment>
	<decl_stmt><decl><type><name pos:line="94" pos:column="9">DWORD</name></type> <name pos:line="94" pos:column="15">grfchostf</name></decl>;</decl_stmt>          <comment type="line" pos:line="94" pos:column="35">// bit flags taken from msochostf values (above)</comment>
	</public>}</block></struct></type> <name pos:line="95" pos:column="11">MSOCHOSTINFO</name>;</typedef>


<comment type="line" pos:line="98" pos:column="1">// idle flags, passed to IMsoComponent::FDoIdle and </comment>
<comment type="line" pos:line="99" pos:column="1">// IMsoStdComponentMgr::FDoIdle.</comment>
<typedef pos:line="100" pos:column="1">typedef <type><enum pos:line="100" pos:column="9">enum
	<block pos:line="101" pos:column="9">{
	<decl><name pos:line="102" pos:column="9">msoidlefPeriodic</name>    <init pos:line="102" pos:column="29">= <expr><lit:literal type="number" pos:line="102" pos:column="31">1</lit:literal></expr></init></decl><op:operator pos:line="102" pos:column="32">,</op:operator>  <comment type="line" pos:line="102" pos:column="35">// periodic idle tasks</comment>
	<decl><name pos:line="103" pos:column="9">msoidlefNonPeriodic</name> <init pos:line="103" pos:column="29">= <expr><lit:literal type="number" pos:line="103" pos:column="31">2</lit:literal></expr></init></decl><op:operator pos:line="103" pos:column="32">,</op:operator>  <comment type="line" pos:line="103" pos:column="35">// any nonperiodic idle task</comment>
	<decl><name pos:line="104" pos:column="9">msoidlefPriority</name>    <init pos:line="104" pos:column="29">= <expr><lit:literal type="number" pos:line="104" pos:column="31">4</lit:literal></expr></init></decl><op:operator pos:line="104" pos:column="32">,</op:operator>  <comment type="line" pos:line="104" pos:column="35">// high priority, nonperiodic idle tasks</comment>
	<decl><name pos:line="105" pos:column="9">msoidlefAll</name>         <init pos:line="105" pos:column="29">= <expr><op:operator pos:line="105" pos:column="31">-</op:operator><lit:literal type="number" pos:line="105" pos:column="32">1</lit:literal></expr></init></decl>  <comment type="line" pos:line="105" pos:column="35">// all idle tasks</comment>
	}</block></enum></type> <name pos:line="106" pos:column="11">MSOIDLE</name>;</typedef>


<comment type="line" pos:line="109" pos:column="1">// Reasons for pushing a message loop, passed to </comment>
<comment type="line" pos:line="110" pos:column="1">// IMsoComponentManager::FPushMessageLoop and </comment>
<comment type="line" pos:line="111" pos:column="1">// IMsoComponentHost::FPushMessageLoop.  The host should remain in message</comment>
<comment type="line" pos:line="112" pos:column="1">// loop until IMsoComponent::FContinueMessageLoop </comment>
<comment type="line" pos:line="113" pos:column="1">// (or IMsoStdComponentMgr::FContinueMessageLoop) returns FALSE.</comment>
<enum pos:line="114" pos:column="1">enum
	<block pos:line="115" pos:column="9">{
	<decl><name pos:line="116" pos:column="9">msoloopFocusWait</name> <init pos:line="116" pos:column="26">= <expr><lit:literal type="number" pos:line="116" pos:column="28">1</lit:literal></expr></init></decl><op:operator pos:line="116" pos:column="29">,</op:operator>  <comment type="line" pos:line="116" pos:column="32">// component is activating host </comment>
	<decl><name pos:line="117" pos:column="9">msoloopDoEvents</name>  <init pos:line="117" pos:column="26">= <expr><lit:literal type="number" pos:line="117" pos:column="28">2</lit:literal></expr></init></decl><op:operator pos:line="117" pos:column="29">,</op:operator>  <comment type="line" pos:line="117" pos:column="32">// component is asking host to process messages</comment>
	<decl><name pos:line="118" pos:column="9">msoloopDebug</name>     <init pos:line="118" pos:column="26">= <expr><lit:literal type="number" pos:line="118" pos:column="28">3</lit:literal></expr></init></decl><op:operator pos:line="118" pos:column="29">,</op:operator>  <comment type="line" pos:line="118" pos:column="32">// component has entered debug mode</comment>
	<decl><name pos:line="119" pos:column="9">msoloopModalForm</name> <init pos:line="119" pos:column="26">= <expr><lit:literal type="number" pos:line="119" pos:column="28">4</lit:literal></expr></init></decl><op:operator pos:line="119" pos:column="29">,</op:operator>   <comment type="line" pos:line="119" pos:column="33">// component is displaying a modal form  </comment>
	<decl><name pos:line="120" pos:column="9">msoloopModalAlert</name> <init pos:line="120" pos:column="27">= <expr><lit:literal type="number" pos:line="120" pos:column="29">5</lit:literal></expr></init></decl>  <comment type="line" pos:line="120" pos:column="32">// Different from ModalForm in the intention that</comment>
							<comment type="line" pos:line="121" pos:column="57">// this should act as much like a blocking call as</comment>
				 			<comment type="line" pos:line="122" pos:column="57">// as possible- app should do no idling in this case</comment>
				 			<comment type="line" pos:line="123" pos:column="57">// if alerts might come up in badly defined states</comment>

	}</block>;</enum>


<comment type="block" pos:line="128" pos:column="1">/* msocstate values: state IDs passed to 
	IMsoComponent::OnEnterState, 
	IMsoComponentManager::OnComponentEnterState/FOnComponentExitState/FInState,
	IMsoComponentHost::OnComponentEnterState,
	IMsoStdComponentMgr::OnHostEnterState/FOnHostExitState/FInState.
	When the host or a component is notified through one of these methods that 
	another entity (component or host) is entering or exiting a state 
	identified by one of these state IDs, the host/component should take
	appropriate action:
		msocstateModal (modal state):
			If app is entering modal state, host/component should disable
			its toplevel windows, and reenable them when app exits this
			state.  Also, when this state is entered or exited, host/component
			should notify approprate inplace objects via 
			IOleInPlaceActiveObject::EnableModeless.
		msocstateRedrawOff (redrawOff state):
			If app is entering redrawOff state, host/component should disable
			repainting of its windows, and reenable repainting when app exits
			this state.
		msocstateWarningsOff (warningsOff state):
			If app is entering warningsOff state, host/component should disable
			the presentation of any user warnings, and reenable this when
			app exits this state.
		msocstateRecording (Recording state):
			Used to notify host/component when Recording is turned on or off. */</comment>
<enum pos:line="153" pos:column="1">enum
	<block pos:line="154" pos:column="9">{
	<decl><name pos:line="155" pos:column="9">msocstateModal</name>       <init pos:line="155" pos:column="30">= <expr><lit:literal type="number" pos:line="155" pos:column="32">1</lit:literal></expr></init></decl><op:operator pos:line="155" pos:column="33">,</op:operator> <comment type="line" pos:line="155" pos:column="35">// modal state; disable toplevel windows</comment>
	<decl><name pos:line="156" pos:column="9">msocstateRedrawOff</name>   <init pos:line="156" pos:column="30">= <expr><lit:literal type="number" pos:line="156" pos:column="32">2</lit:literal></expr></init></decl><op:operator pos:line="156" pos:column="33">,</op:operator> <comment type="line" pos:line="156" pos:column="35">// redrawOff state; disable window repainting</comment>
	<decl><name pos:line="157" pos:column="9">msocstateWarningsOff</name> <init pos:line="157" pos:column="30">= <expr><lit:literal type="number" pos:line="157" pos:column="32">3</lit:literal></expr></init></decl><op:operator pos:line="157" pos:column="33">,</op:operator> <comment type="line" pos:line="157" pos:column="35">// warningsOff state; disable user warnings</comment>
	<decl><name pos:line="158" pos:column="9">msocstateRecording</name>   <init pos:line="158" pos:column="30">= <expr><lit:literal type="number" pos:line="158" pos:column="32">4</lit:literal></expr></init></decl><op:operator pos:line="158" pos:column="33">,</op:operator> <comment type="line" pos:line="158" pos:column="35">// Recording state</comment>
	}</block>;</enum>


<comment type="block" pos:line="162" pos:column="1">/*             ** Comments on State Contexts **
	IMsoComponentManager::FCreateSubComponentManager allows one to create a 
	hierarchical tree of component managers.  This tree is used to maintain 
	multiple contexts with regard to msocstateXXX states.  These contexts are 
	referred to as 'state contexts'.
	Each component manager in the tree defines a state context.  The
	components registered with a particular component manager or any of its
	descendents live within that component manager's state context.  Calls
	to IMsoComponentManager::OnComponentEnterState/FOnComponentExitState
	can be used to	affect all components, only components within the component
	manager's state context, or only those components that are outside of the
	component manager's state context.  IMsoComponentManager::FInState is used
	to query the state of the component manager's state context at its root.

   msoccontext values: context indicators passed to 
	IMsoComponentManager::OnComponentEnterState/FOnComponentExitState.
	These values indicate the state context that is to be affected by the
	state change. 
	In IMsoComponentManager::OnComponentEnterState/FOnComponentExitState,
	the comp mgr informs only those components/host that are within the
	specified state context. */</comment>
<enum pos:line="183" pos:column="1">enum
	<block pos:line="184" pos:column="9">{
	<decl><name pos:line="185" pos:column="9">msoccontextAll</name>    <init pos:line="185" pos:column="27">= <expr><lit:literal type="number" pos:line="185" pos:column="29">0</lit:literal></expr></init></decl><op:operator pos:line="185" pos:column="30">,</op:operator> <comment type="line" pos:line="185" pos:column="32">// all state contexts in state context tree</comment>
	<decl><name pos:line="186" pos:column="9">msoccontextMine</name>   <init pos:line="186" pos:column="27">= <expr><lit:literal type="number" pos:line="186" pos:column="29">1</lit:literal></expr></init></decl><op:operator pos:line="186" pos:column="30">,</op:operator> <comment type="line" pos:line="186" pos:column="32">// component manager's state context</comment>
	<decl><name pos:line="187" pos:column="9">msoccontextOthers</name> <init pos:line="187" pos:column="27">= <expr><lit:literal type="number" pos:line="187" pos:column="29">2</lit:literal></expr></init></decl><op:operator pos:line="187" pos:column="30">,</op:operator> <comment type="line" pos:line="187" pos:column="32">// all other state contexts outside of comp mgr's</comment>
	}</block>;</enum>


<comment type="block" pos:line="191" pos:column="1">/*     ** WM_MOUSEACTIVATE Note (for top level compoenents and host) **
	If the active (or tracking) comp's reg info indicates that it
	wants mouse messages, then no MA_xxxANDEAT value should be returned 
	from WM_MOUSEACTIVATE, so that the active (or tracking) comp will be able
	to process the resulting mouse message.  If one does not want to examine
	the reg info, no MA_xxxANDEAT value should be returned from 
	WM_MOUSEACTIVATE if any comp is active (or tracking).
	One can query the reg info of the active (or tracking) component at any
	time via IMsoComponentManager::FGetActiveComponent. */</comment>

<comment type="block" pos:line="201" pos:column="1">/* msogac values: values passed to 
	IMsoComponentManager::FGetActiveComponent. */</comment> 
<enum pos:line="203" pos:column="1">enum
	<block pos:line="204" pos:column="9">{
	<decl><name pos:line="205" pos:column="9">msogacActive</name>    <init pos:line="205" pos:column="25">= <expr><lit:literal type="number" pos:line="205" pos:column="27">0</lit:literal></expr></init></decl><op:operator pos:line="205" pos:column="28">,</op:operator> <comment type="line" pos:line="205" pos:column="30">// retrieve true active component</comment>
	<decl><name pos:line="206" pos:column="9">msogacTracking</name>   <init pos:line="206" pos:column="26">= <expr><lit:literal type="number" pos:line="206" pos:column="28">1</lit:literal></expr></init></decl><op:operator pos:line="206" pos:column="29">,</op:operator> <comment type="line" pos:line="206" pos:column="31">// retrieve tracking component</comment>
	<decl><name pos:line="207" pos:column="9">msogacTrackingOrActive</name> <init pos:line="207" pos:column="32">= <expr><lit:literal type="number" pos:line="207" pos:column="34">2</lit:literal></expr></init></decl><op:operator pos:line="207" pos:column="35">,</op:operator> <comment type="line" pos:line="207" pos:column="37">// retrieve tracking component if one exists,</comment>
	                            <comment type="line" pos:line="208" pos:column="37">// otherwise retrieve true active component</comment>
	}</block>;</enum>


<comment type="block" pos:line="212" pos:column="1">/* msocWindow values: values passed to IMsoComponent::HwndGetWindow. */</comment> 
<enum pos:line="213" pos:column="1">enum
	<block pos:line="214" pos:column="9">{
	<decl><name pos:line="215" pos:column="9">msocWindowFrameToplevel</name> <init pos:line="215" pos:column="33">= <expr><lit:literal type="number" pos:line="215" pos:column="35">0</lit:literal></expr></init></decl><op:operator pos:line="215" pos:column="36">,</op:operator>
		<comment type="block" pos:line="216" pos:column="17">/* MDI Apps should return the MDI frame (not MDI client) or App frame
			window, and SDI Apps should return the frame window which hosts the
			component. Basically it should be the topmost window which owns the
			component. For a toolbar set this will be the toplevel owner of
			TBS::m_hwnd. */</comment>

	<decl><name pos:line="222" pos:column="9">msocWindowFrameOwner</name> <init pos:line="222" pos:column="30">= <expr><lit:literal type="number" pos:line="222" pos:column="32">1</lit:literal></expr></init></decl><op:operator pos:line="222" pos:column="33">,</op:operator>
		<comment type="block" pos:line="223" pos:column="17">/* This is the window which owns the component. It could be same as
			the window obtained by msocWindowFrameTopLevel or be an owned window
			of that window. For a toolbar set this will be TBS::m_hwnd. */</comment>

	<decl><name pos:line="227" pos:column="9">msocWindowComponent</name> <init pos:line="227" pos:column="29">= <expr><lit:literal type="number" pos:line="227" pos:column="31">2</lit:literal></expr></init></decl><op:operator pos:line="227" pos:column="32">,</op:operator>
		<comment type="block" pos:line="228" pos:column="17">/* This is the "main" window of the component (if it has one). */</comment>

	<decl><name pos:line="230" pos:column="9">msocWindowDlgOwner</name> <init pos:line="230" pos:column="28">= <expr><lit:literal type="number" pos:line="230" pos:column="30">3</lit:literal></expr></init></decl><op:operator pos:line="230" pos:column="31">,</op:operator>
		<comment type="block" pos:line="231" pos:column="17">/* Caller wishes to display a dialog to be parented by the component.
			Component should return a window suitable for use as the dialog's
			owner window. */</comment>  
	}</block>;</enum>

<comment type="block" pos:line="236" pos:column="1">/* Values passed to IMsoComponentManager::FSetTrackingComponent. */</comment> 
<enum pos:line="237" pos:column="1">enum
	<block pos:line="238" pos:column="9">{
	<decl><name pos:line="239" pos:column="9">msostcBeginTracking</name> <init pos:line="239" pos:column="29">= <expr><lit:literal type="number" pos:line="239" pos:column="31">1</lit:literal></expr></init></decl><op:operator pos:line="239" pos:column="32">,</op:operator>  <comment type="line" pos:line="239" pos:column="35">// begin tracking normally</comment>
	<decl><name pos:line="240" pos:column="9">msostcNonBlocking</name> <init pos:line="240" pos:column="27">= <expr><lit:literal type="number" pos:line="240" pos:column="29">2</lit:literal></expr></init></decl><op:operator pos:line="240" pos:column="30">,</op:operator>    <comment type="line" pos:line="240" pos:column="35">// don't report to the app that the component is</comment>
	                          <comment type="line" pos:line="241" pos:column="35">// a tracking component.  used for workpanes and</comment>
	                          <comment type="line" pos:line="242" pos:column="35">// other pane-like toolbars.</comment>
	}</block>;</enum>


<comment type="block" format="doxygen" pos:line="246" pos:column="1">/****************************************************************************
	Defines the IMsoComponent interface

	Any component that needs idle time, the ability to process
	messages before they are translated 
	(for example, to call TranslateAccelerator or IsDialogMessage),
	notification about modal states,
	or the ability push message loops 
	must implement this interface and register with the Component Manager.
****************************************************************************/</comment>
<cpp:undef pos:line="256" pos:column="1">#<cpp:directive pos:line="256" pos:column="2">undef</cpp:directive>  <name pos:line="256" pos:column="9">INTERFACE</name></cpp:undef>
<cpp:define pos:line="257" pos:column="1">#<cpp:directive pos:line="257" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="257" pos:column="9">INTERFACE</name></cpp:macro>  <cpp:value pos:line="257" pos:column="20">IMsoComponent</cpp:value></cpp:define>

<macro><name pos:line="259" pos:column="1">DECLARE_INTERFACE_</name><argument_list pos:line="259" pos:column="19">(<argument pos:line="259" pos:column="20">IMsoComponent</argument>, <argument pos:line="259" pos:column="35">IUnknown</argument>)</argument_list></macro>
	<block pos:line="260" pos:column="9">{
	<function_decl><type><name pos:line="261" pos:column="9">BEGIN_MSOINTERFACE</name>
	<comment type="line" pos:line="262" pos:column="9">// *** IUnknown methods ***</comment>
	<name pos:line="263" pos:column="9">MSOMETHOD</name></type>(<name pos:line="263" pos:column="19">QueryInterface</name>) <parameter_list pos:line="263" pos:column="35">(<param><decl><type><name pos:line="263" pos:column="36">THIS_</name> <name pos:line="263" pos:column="42">REFIID</name></type> <name pos:line="263" pos:column="49">riid</name></decl></param>, <param><decl><type><name pos:line="263" pos:column="55">void</name> <type:modifier pos:line="263" pos:column="60">*</type:modifier><type:modifier pos:line="263" pos:column="61">*</type:modifier></type><name pos:line="263" pos:column="62">ppvObj</name></decl></param>)</parameter_list> <name pos:line="263" pos:column="70">PURE</name>;</function_decl>
	<macro><name pos:line="264" pos:column="9">MSOMETHOD_</name><argument_list pos:line="264" pos:column="19">(<argument pos:line="264" pos:column="20">ULONG</argument>, <argument pos:line="264" pos:column="27">AddRef</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="264" pos:column="35">(</op:operator><name pos:line="264" pos:column="36">THIS</name><op:operator pos:line="264" pos:column="40">)</op:operator> <name pos:line="264" pos:column="42">PURE</name></expr>;</expr_stmt>
	<macro><name pos:line="265" pos:column="9">MSOMETHOD_</name><argument_list pos:line="265" pos:column="19">(<argument pos:line="265" pos:column="20">ULONG</argument>, <argument pos:line="265" pos:column="27">Release</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="265" pos:column="36">(</op:operator><name pos:line="265" pos:column="37">THIS</name><op:operator pos:line="265" pos:column="41">)</op:operator> <name pos:line="265" pos:column="43">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="267" pos:column="9">/* Standard FDebugMessage method.
	   Since IMsoComponent is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */</comment>
	<decl_stmt><decl><type><name pos:line="271" pos:column="9">MSODEBUGMETHOD</name></type>

	<comment type="block" pos:line="273" pos:column="9">/* Give component a chance to process the message pMsg before it is
		translated and dispatched. Component can do TranslateAccelerator,
		do IsDialogMessage, modify pMsg, or take some other action.
		Return TRUE if the message is consumed, FALSE otherwise. */</comment>
	<name pos:line="277" pos:column="9">MSOMETHOD_</name><argument_list pos:line="277" pos:column="19">(<argument><expr><name pos:line="277" pos:column="20">BOOL</name></expr></argument>, <argument><expr><name pos:line="277" pos:column="26">FPreTranslateMessage</name></expr></argument>)</argument_list> <argument_list pos:line="277" pos:column="48">(<argument><expr><name pos:line="277" pos:column="49">THIS_</name> <name pos:line="277" pos:column="55">MSG</name> <op:operator pos:line="277" pos:column="59">*</op:operator><name pos:line="277" pos:column="60">pMsg</name></expr></argument>)</argument_list> <name pos:line="277" pos:column="66">PURE</name></decl>;</decl_stmt>

	<comment type="block" pos:line="279" pos:column="9">/* Notify component when app enters or exits (as indicated by fEnter)
		the state identified by uStateID (a value from msocstate enumeration).
		Component should take action depending on value of uStateID
		(see msocstate comments, above).
		
		Note: If n calls are made with TRUE fEnter, component should consider 
		the state to be in effect until n calls are made with FALSE fEnter.
		
		Note: Components should be aware that it is possible for this method to
		be called with FALSE fEnter more	times than it was called with TRUE 
		fEnter (so, for example, if component is maintaining a state counter
		(incremented when this method is called with TRUE fEnter, decremented
		when called with FALSE fEnter), the counter should not be decremented
		for FALSE fEnter if it is already at zero.)  */</comment>
	<macro><name pos:line="293" pos:column="9">MSOMETHOD_</name><argument_list pos:line="293" pos:column="19">(<argument pos:line="293" pos:column="20">void</argument>, <argument pos:line="293" pos:column="26">OnEnterState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="293" pos:column="40">(</op:operator><name pos:line="293" pos:column="41">THIS_</name> <name pos:line="293" pos:column="47">ULONG</name> <name pos:line="293" pos:column="53">uStateID</name><op:operator pos:line="293" pos:column="61">,</op:operator> <name pos:line="293" pos:column="63">BOOL</name> <name pos:line="293" pos:column="68">fEnter</name><op:operator pos:line="293" pos:column="74">)</op:operator> <name pos:line="293" pos:column="76">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="295" pos:column="9">/* Notify component when the host application gains or loses activation.
		If fActive is TRUE, the host app is being activated and dwOtherThreadID
		is the ID of the thread owning the window being deactivated.
		If fActive is FALSE, the host app is being deactivated and 
		dwOtherThreadID is the ID of the thread owning the window being 
		activated.
		Note: this method is not called when both the window being activated
		and the one being deactivated belong to the host app. */</comment>
	<macro><name pos:line="303" pos:column="9">MSOMETHOD_</name><argument_list pos:line="303" pos:column="19">(<argument pos:line="303" pos:column="20">void</argument>, <argument pos:line="303" pos:column="26">OnAppActivate</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="303" pos:column="41">(</op:operator><name pos:line="303" pos:column="42">THIS_</name> 
		<name pos:line="304" pos:column="17">BOOL</name> <name pos:line="304" pos:column="22">fActive</name><op:operator pos:line="304" pos:column="29">,</op:operator> <name pos:line="304" pos:column="31">DWORD</name> <name pos:line="304" pos:column="37">dwOtherThreadID</name><op:operator pos:line="304" pos:column="52">)</op:operator> <name pos:line="304" pos:column="54">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="306" pos:column="9">/* Notify the active component that it has lost its active status because
		the host or another component has become active. */</comment>
	<macro><name pos:line="308" pos:column="9">MSOMETHOD_</name><argument_list pos:line="308" pos:column="19">(<argument pos:line="308" pos:column="20">void</argument>, <argument pos:line="308" pos:column="26">OnLoseActivation</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="308" pos:column="44">(</op:operator><name pos:line="308" pos:column="45">THIS</name><op:operator pos:line="308" pos:column="49">)</op:operator> <name pos:line="308" pos:column="51">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="310" pos:column="9">/* Notify component when a new object is being activated.
		If pic is non-NULL, then it is the component that is being activated.
		In this case, fSameComponent is TRUE if pic is the same component as
		the callee of this method, and pcrinfo is the reg info of pic.
		If pic is NULL and fHostIsActivating is TRUE, then the host is the
		object being activated, and pchostinfo is its host info.
		If pic is NULL and fHostIsActivating is FALSE, then there is no current
		active object.

		If pic is being activated and pcrinfo-&gt;grf has the 
		msocrfExclusiveBorderSpace bit set, component should hide its border
		space tools (toolbars, status bars, etc.);
		component should also do this if host is activating and 
		pchostinfo-&gt;grfchostf has the msochostfExclusiveBorderSpace bit set.
		In either of these cases, component should unhide its border space
		tools the next time it is activated.

		If pic is being activated and pcrinfo-&gt;grf has the
		msocrfExclusiveActivation bit is set, then pic is being activated in
		"ExclusiveActive" mode.  
		Component should retrieve the top frame window that is hosting pic
		(via pic-&gt;HwndGetWindow(msocWindowFrameToplevel, 0)).  
		If this window is different from component's own top frame window, 
			component should disable its windows and do other things it would do
			when receiving OnEnterState(msocstateModal, TRUE) notification. 
		Otherwise, if component is top-level, 
			it should refuse to have its window activated by appropriately
			processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
		Component should remain in one of these states until the 
		ExclusiveActive mode ends, indicated by a future call to 
		OnActivationChange with ExclusiveActivation bit not set or with NULL
		pcrinfo. */</comment>
	<macro><name pos:line="342" pos:column="9">MSOMETHOD_</name><argument_list pos:line="342" pos:column="19">(<argument pos:line="342" pos:column="20">void</argument>, <argument pos:line="342" pos:column="26">OnActivationChange</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="342" pos:column="46">(</op:operator><name pos:line="342" pos:column="47">THIS_</name> 
		<name pos:line="343" pos:column="17">IMsoComponent</name> <op:operator pos:line="343" pos:column="31">*</op:operator><name pos:line="343" pos:column="32">pic</name><op:operator pos:line="343" pos:column="35">,</op:operator> 
		<name pos:line="344" pos:column="17">BOOL</name> <name pos:line="344" pos:column="22">fSameComponent</name><op:operator pos:line="344" pos:column="36">,</op:operator>
		const <name pos:line="345" pos:column="23">MSOCRINFO</name> <op:operator pos:line="345" pos:column="33">*</op:operator><name pos:line="345" pos:column="34">pcrinfo</name><op:operator pos:line="345" pos:column="41">,</op:operator>
		<name pos:line="346" pos:column="17">BOOL</name> <name pos:line="346" pos:column="22">fHostIsActivating</name><op:operator pos:line="346" pos:column="39">,</op:operator>
		const <name pos:line="347" pos:column="23">MSOCHOSTINFO</name> <op:operator pos:line="347" pos:column="36">*</op:operator><name pos:line="347" pos:column="37">pchostinfo</name><op:operator pos:line="347" pos:column="47">,</op:operator> 
		<name pos:line="348" pos:column="17">DWORD</name> <name pos:line="348" pos:column="23">dwReserved</name><op:operator pos:line="348" pos:column="33">)</op:operator> <name pos:line="348" pos:column="35">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="350" pos:column="9">/* Give component a chance to do idle time tasks.  grfidlef is a group of
		bit flags taken from the enumeration of msoidlef values (above),
		indicating the type of idle tasks to perform.  
		Component may periodically call IMsoComponentManager::FContinueIdle; 
		if this method returns FALSE, component should terminate its idle 
		time processing and return.  
		Return TRUE if more time is needed to perform the idle time tasks, 
		FALSE otherwise.
		Note: If a component reaches a point where it has no idle tasks
		and does not need FDoIdle calls, it should remove its idle task
		registration via IMsoComponentManager::FUpdateComponentRegistration.
		Note: If this method is called on while component is performing a 
		tracking operation, component should only perform idle time tasks that
		it deems are appropriate to perform during tracking. */</comment>
	<macro><name pos:line="364" pos:column="9">MSOMETHOD_</name><argument_list pos:line="364" pos:column="19">(<argument pos:line="364" pos:column="20">BOOL</argument>, <argument pos:line="364" pos:column="26">FDoIdle</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="364" pos:column="35">(</op:operator><name pos:line="364" pos:column="36">THIS_</name> <name pos:line="364" pos:column="42">DWORD</name> <name pos:line="364" pos:column="48">grfidlef</name><op:operator pos:line="364" pos:column="56">)</op:operator> <name pos:line="364" pos:column="58">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="366" pos:column="9">/* Called during each iteration of a message loop that the component
		pushed. uReason and pvLoopData are the reason and the component private 
		data that were passed to IMsoComponentManager::FPushMessageLoop.
		This method is called after peeking the next message in the queue
		(via PeekMessage) but before the message is removed from the queue.
		The peeked message is passed in the pMsgPeeked param (NULL if no
		message is in the queue).  This method may be additionally called when
		the next message has already been removed from the queue, in which case
		pMsgPeeked is passed as NULL.
		Return TRUE if the message loop should continue, FALSE otherwise.
		If FALSE is returned, the component manager terminates the loop without
		removing pMsgPeeked from the queue. */</comment>
	<macro><name pos:line="378" pos:column="9">MSOMETHOD_</name><argument_list pos:line="378" pos:column="19">(<argument pos:line="378" pos:column="20">BOOL</argument>, <argument pos:line="378" pos:column="26">FContinueMessageLoop</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="378" pos:column="48">(</op:operator><name pos:line="378" pos:column="49">THIS_</name> 
		<name pos:line="379" pos:column="17">ULONG</name> <name pos:line="379" pos:column="23">uReason</name><op:operator pos:line="379" pos:column="30">,</op:operator> <name pos:line="379" pos:column="32">void</name> <op:operator pos:line="379" pos:column="37">*</op:operator><name pos:line="379" pos:column="38">pvLoopData</name><op:operator pos:line="379" pos:column="48">,</op:operator> <name pos:line="379" pos:column="50">MSG</name> <op:operator pos:line="379" pos:column="54">*</op:operator><name pos:line="379" pos:column="55">pMsgPeeked</name><op:operator pos:line="379" pos:column="65">)</op:operator> <name pos:line="379" pos:column="67">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="381" pos:column="9">/* Called when component manager wishes to know if the component is in a
		state in which it can terminate.  If fPromptUser is FALSE, component
		should simply return TRUE if it can terminate, FALSE otherwise.
		If fPromptUser is TRUE, component should return TRUE if it can
		terminate without prompting the user; otherwise it should prompt the
		user, either 1.) asking user if it can terminate and returning TRUE
		or FALSE appropriately, or 2.) giving an indication as to why it
		cannot terminate and returning FALSE. */</comment>
	<macro><name pos:line="389" pos:column="9">MSOMETHOD_</name><argument_list pos:line="389" pos:column="19">(<argument pos:line="389" pos:column="20">BOOL</argument>, <argument pos:line="389" pos:column="26">FQueryTerminate</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="389" pos:column="43">(</op:operator><name pos:line="389" pos:column="44">THIS_</name> <name pos:line="389" pos:column="50">BOOL</name> <name pos:line="389" pos:column="55">fPromptUser</name><op:operator pos:line="389" pos:column="66">)</op:operator> <name pos:line="389" pos:column="68">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="391" pos:column="9">/* Called when component manager wishes to terminate the component's
		registration.  Component should revoke its registration with component
		manager, release references to component manager and perform any
		necessary cleanup. */</comment>
	<macro><name pos:line="395" pos:column="9">MSOMETHOD_</name><argument_list pos:line="395" pos:column="19">(<argument pos:line="395" pos:column="20">void</argument>, <argument pos:line="395" pos:column="26">Terminate</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="395" pos:column="37">(</op:operator><name pos:line="395" pos:column="38">THIS</name><op:operator pos:line="395" pos:column="42">)</op:operator> <name pos:line="395" pos:column="44">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="397" pos:column="9">/* Called to retrieve a window associated with the component, as specified
		by dwWhich, a msocWindowXXX value (see msocWindow, above).
		dwReserved is reserved for future use and should be zero.
		Component should return the desired window or NULL if no such window
		exists. */</comment>
	<macro><name pos:line="402" pos:column="9">MSOMETHOD_</name><argument_list pos:line="402" pos:column="19">(<argument pos:line="402" pos:column="20">HWND</argument>, <argument pos:line="402" pos:column="26">HwndGetWindow</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="402" pos:column="41">(</op:operator><name pos:line="402" pos:column="42">THIS_</name> 
		<name pos:line="403" pos:column="17">DWORD</name> <name pos:line="403" pos:column="23">dwWhich</name><op:operator pos:line="403" pos:column="30">,</op:operator> <name pos:line="403" pos:column="32">DWORD</name> <name pos:line="403" pos:column="38">dwReserved</name><op:operator pos:line="403" pos:column="48">)</op:operator> <name pos:line="403" pos:column="50">PURE</name></expr>;</expr_stmt>
	}</block><empty_stmt pos:line="404" pos:column="10">;</empty_stmt>


<comment type="block" format="doxygen" pos:line="407" pos:column="1">/****************************************************************************
	Defines the IMsoComponentManager interface

	A component manager is an object implementing the IMsoComponentManager
	interface.  The component manager coordinates components with its message
	loop for proper distribution of idle time and pre-translation message
	processing.	
	It also coordinates modalities and the pushing of message loops.
	The host application can implement its own component manager and register
	it via MsoFSetComponentManager or it can make use of the office supplied
	component manager via MsoFCreateStdComponentManager.
****************************************************************************/</comment>
<cpp:undef pos:line="419" pos:column="1">#<cpp:directive pos:line="419" pos:column="2">undef</cpp:directive>  <name pos:line="419" pos:column="9">INTERFACE</name></cpp:undef>
<cpp:define pos:line="420" pos:column="1">#<cpp:directive pos:line="420" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="420" pos:column="9">INTERFACE</name></cpp:macro>  <cpp:value pos:line="420" pos:column="20">IMsoComponentManager</cpp:value></cpp:define>

<macro><name pos:line="422" pos:column="1">DECLARE_INTERFACE_</name><argument_list pos:line="422" pos:column="19">(<argument pos:line="422" pos:column="20">IMsoComponentManager</argument>, <argument pos:line="422" pos:column="42">IUnknown</argument>)</argument_list></macro>
	<block pos:line="423" pos:column="9">{
	<function_decl><type><name pos:line="424" pos:column="9">BEGIN_MSOINTERFACE</name>
	<comment type="line" pos:line="425" pos:column="9">// *** IUnknown methods ***</comment>
	<name pos:line="426" pos:column="9">MSOMETHOD</name></type>(<name pos:line="426" pos:column="19">QueryInterface</name>) <parameter_list pos:line="426" pos:column="35">(<param><decl><type><name pos:line="426" pos:column="36">THIS_</name> <name pos:line="426" pos:column="42">REFIID</name></type> <name pos:line="426" pos:column="49">riid</name></decl></param>, <param><decl><type><name pos:line="426" pos:column="55">void</name> <type:modifier pos:line="426" pos:column="60">*</type:modifier><type:modifier pos:line="426" pos:column="61">*</type:modifier></type><name pos:line="426" pos:column="62">ppvObj</name></decl></param>)</parameter_list> <name pos:line="426" pos:column="70">PURE</name>;</function_decl>
	<macro><name pos:line="427" pos:column="9">MSOMETHOD_</name><argument_list pos:line="427" pos:column="19">(<argument pos:line="427" pos:column="20">ULONG</argument>, <argument pos:line="427" pos:column="27">AddRef</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="427" pos:column="35">(</op:operator><name pos:line="427" pos:column="36">THIS</name><op:operator pos:line="427" pos:column="40">)</op:operator> <name pos:line="427" pos:column="42">PURE</name></expr>;</expr_stmt>
	<macro><name pos:line="428" pos:column="9">MSOMETHOD_</name><argument_list pos:line="428" pos:column="19">(<argument pos:line="428" pos:column="20">ULONG</argument>, <argument pos:line="428" pos:column="27">Release</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="428" pos:column="36">(</op:operator><name pos:line="428" pos:column="37">THIS</name><op:operator pos:line="428" pos:column="41">)</op:operator> <name pos:line="428" pos:column="43">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="430" pos:column="9">/* Return in *ppvObj an implementation of interface iid for service
		guidService (same as IServiceProvider::QueryService).
		Return NOERROR if the requested service is supported, otherwise return
		NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE). */</comment>
	<function_decl><type><name pos:line="434" pos:column="9">MSOMETHOD</name></type>(<name pos:line="434" pos:column="19">QueryService</name>) <parameter_list pos:line="434" pos:column="33">(<param><decl><type><name pos:line="434" pos:column="34">THIS_</name>
		<name pos:line="435" pos:column="17">REFGUID</name></type> <name pos:line="435" pos:column="25">guidService</name></decl></param>, <param><decl><type><name pos:line="435" pos:column="38">REFIID</name></type> <name pos:line="435" pos:column="45">iid</name></decl></param>, <param><decl><type><name pos:line="435" pos:column="50">void</name> <type:modifier pos:line="435" pos:column="55">*</type:modifier><type:modifier pos:line="435" pos:column="56">*</type:modifier></type><name pos:line="435" pos:column="57">ppvObj</name></decl></param>)</parameter_list> <name pos:line="435" pos:column="65">PURE</name>;</function_decl>

	<comment type="block" pos:line="437" pos:column="9">/* Standard FDebugMessage method.
	   Since IMsoComponentManager is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */</comment>
	<decl_stmt><decl><type><name pos:line="441" pos:column="9">MSODEBUGMETHOD</name></type>

	<comment type="block" pos:line="443" pos:column="9">/* Register component piComponent and its registration info pcrinfo with
		this component manager.  Return in *pdwComponentID a cookie which will
		identify the component when it calls other IMsoComponentManager
		methods.
		Return TRUE if successful, FALSE otherwise. */</comment>
	<name pos:line="448" pos:column="9">MSOMETHOD_</name><argument_list pos:line="448" pos:column="19">(<argument><expr><name pos:line="448" pos:column="20">BOOL</name></expr></argument>, <argument><expr><name pos:line="448" pos:column="26">FRegisterComponent</name></expr></argument>)</argument_list> <argument_list pos:line="448" pos:column="46">(<argument><expr><name pos:line="448" pos:column="47">THIS_</name>
		<name pos:line="449" pos:column="17">IMsoComponent</name> <op:operator pos:line="449" pos:column="31">*</op:operator><name pos:line="449" pos:column="32">piComponent</name></expr></argument>, <argument><expr pos:line="449" pos:column="45">const <name pos:line="449" pos:column="51">MSOCRINFO</name> <op:operator pos:line="449" pos:column="61">*</op:operator><name pos:line="449" pos:column="62">pcrinfo</name></expr></argument>, 
		<argument><expr><name pos:line="450" pos:column="17">DWORD_PTR</name> <op:operator pos:line="450" pos:column="27">*</op:operator><name pos:line="450" pos:column="28">pdwComponentID</name></expr></argument>)</argument_list> <name pos:line="450" pos:column="44">PURE</name></decl>;</decl_stmt>
	
	<comment type="block" pos:line="452" pos:column="9">/* Undo the registration of the component identified by dwComponentID
		(the cookie returned from the FRegisterComponent method).
		Return TRUE if successful, FALSE otherwise. */</comment>
	<macro><name pos:line="455" pos:column="9">MSOMETHOD_</name><argument_list pos:line="455" pos:column="19">(<argument pos:line="455" pos:column="20">BOOL</argument>, <argument pos:line="455" pos:column="26">FRevokeComponent</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="455" pos:column="44">(</op:operator><name pos:line="455" pos:column="45">THIS_</name> <name pos:line="455" pos:column="51">DWORD_PTR</name> <name pos:line="455" pos:column="61">dwComponentID</name><op:operator pos:line="455" pos:column="74">)</op:operator> <name pos:line="455" pos:column="76">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="457" pos:column="9">/* Update the registration info of the component identified by
		dwComponentID (the cookie returned from FRegisterComponent) with the
		new registration information pcrinfo.
		Typically this is used to update the idle time registration data, but
		can be used to update other registration data as well.
		Return TRUE if successful, FALSE otherwise. */</comment>
	<macro><name pos:line="463" pos:column="9">MSOMETHOD_</name><argument_list pos:line="463" pos:column="19">(<argument pos:line="463" pos:column="20">BOOL</argument>, <argument pos:line="463" pos:column="26">FUpdateComponentRegistration</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="463" pos:column="56">(</op:operator><name pos:line="463" pos:column="57">THIS_</name> 
		<name pos:line="464" pos:column="17">DWORD_PTR</name> <name pos:line="464" pos:column="27">dwComponentID</name><op:operator pos:line="464" pos:column="40">,</op:operator> const <name pos:line="464" pos:column="48">MSOCRINFO</name> <op:operator pos:line="464" pos:column="58">*</op:operator><name pos:line="464" pos:column="59">pcrinfo</name><op:operator pos:line="464" pos:column="66">)</op:operator> <name pos:line="464" pos:column="68">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="466" pos:column="9">/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) has been activated.
		The active component gets the	chance to process messages before they
		are dispatched (via IMsoComponent::FPreTranslateMessage) and typically
		gets first shot at idle time after the host.
		This method fails if another component is already Exclusively Active.
		In this case, FALSE is returned and SetLastError is set to 
		msoerrACompIsXActive (comp usually need not take any special action
		in this case).
		Return TRUE if successful. */</comment>
	<macro><name pos:line="476" pos:column="9">MSOMETHOD_</name><argument_list pos:line="476" pos:column="19">(<argument pos:line="476" pos:column="20">BOOL</argument>, <argument pos:line="476" pos:column="26">FOnComponentActivate</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="476" pos:column="48">(</op:operator><name pos:line="476" pos:column="49">THIS_</name> <name pos:line="476" pos:column="55">DWORD_PTR</name> <name pos:line="476" pos:column="65">dwComponentID</name><op:operator pos:line="476" pos:column="78">)</op:operator> <name pos:line="476" pos:column="80">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="478" pos:column="9">/* Called to inform component manager that  component identified by 
		dwComponentID (cookie returned from FRegisterComponent) wishes
		to perform a tracking operation (such as mouse tracking).
		The component calls this method with fTrack == TRUE to begin the
		tracking operation and with fTrack == FALSE to end the operation.
		During the tracking operation the component manager routes messages
		to the tracking component (via IMsoComponent::FPreTranslateMessage)
		rather than to the active component.  When the tracking operation ends,
		the component manager should resume routing messages to the active
		component.  
		Note: component manager should perform no idle time processing during a
		      tracking operation other than give the tracking component idle
		      time via IMsoComponent::FDoIdle.
		Note: there can only be one tracking component at a time.
		Return TRUE if successful, FALSE otherwise.  */</comment>
	<macro><name pos:line="493" pos:column="9">MSOMETHOD_</name><argument_list pos:line="493" pos:column="19">(<argument pos:line="493" pos:column="20">BOOL</argument>, <argument pos:line="493" pos:column="26">FSetTrackingComponent</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="493" pos:column="49">(</op:operator><name pos:line="493" pos:column="50">THIS_</name> 
		<name pos:line="494" pos:column="17">DWORD</name> <name pos:line="494" pos:column="23">dwComponentID</name><op:operator pos:line="494" pos:column="36">,</op:operator> <name pos:line="494" pos:column="38">ULONG</name> <name pos:line="494" pos:column="44">grftrack</name><op:operator pos:line="494" pos:column="52">)</op:operator> <name pos:line="494" pos:column="54">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="496" pos:column="9">/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) is entering the state
		identified by uStateID (msocstateXXX value).  (For convenience when
		dealing with sub CompMgrs, the host can call this method passing 0 for
		dwComponentID.)  
		Component manager should notify all other interested components within
		the state context indicated by uContext (a msoccontextXXX value),
		excluding those within the state context of a CompMgr in rgpicmExclude,
		via IMsoComponent::OnEnterState (see "Comments on State Contexts", 
		above).
		Component Manager should also take appropriate action depending on the 
		value of uStateID (see msocstate comments, above).
		dwReserved is reserved for future use and should be zero.

		rgpicmExclude (can be NULL) is an array of cpicmExclude CompMgrs (can
		include root CompMgr and/or sub CompMgrs); components within the state
		context of a CompMgr appearing in this	array should NOT be notified of 
		the state change (note: if uContext	is msoccontextMine, the only 
		CompMgrs in rgpicmExclude that are checked for exclusion are those that 
		are sub CompMgrs of this Component Manager, since all other CompMgrs 
		are outside of this Component Manager's state context anyway.)

		Note: Calls to this method are symmetric with calls to 
		FOnComponentExitState. 
		That is, if n OnComponentEnterState calls are made, the component is
		considered to be in the state until n FOnComponentExitState calls are
		made.  Before revoking its registration a component must make a 
		sufficient number of FOnComponentExitState calls to offset any
		outstanding OnComponentEnterState calls it has made.

		Note: inplace objects should not call this method with
		uStateID == msocstateModal when entering modal state. Such objects
		should call IOleInPlaceFrame::EnableModeless instead. */</comment>
	<macro><name pos:line="529" pos:column="9">MSOMETHOD_</name><argument_list pos:line="529" pos:column="19">(<argument pos:line="529" pos:column="20">void</argument>, <argument pos:line="529" pos:column="26">OnComponentEnterState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="529" pos:column="49">(</op:operator><name pos:line="529" pos:column="50">THIS_</name> 
		<name pos:line="530" pos:column="17">DWORD_PTR</name> <name pos:line="530" pos:column="27">dwComponentID</name><op:operator pos:line="530" pos:column="40">,</op:operator> 
		<name pos:line="531" pos:column="17">ULONG</name> <name pos:line="531" pos:column="23">uStateID</name><op:operator pos:line="531" pos:column="31">,</op:operator> 
		<name pos:line="532" pos:column="17">ULONG</name> <name pos:line="532" pos:column="23">uContext</name><op:operator pos:line="532" pos:column="31">,</op:operator>
		<name pos:line="533" pos:column="17">ULONG</name> <name pos:line="533" pos:column="23">cpicmExclude</name><op:operator pos:line="533" pos:column="35">,</op:operator>
		<name pos:line="534" pos:column="17">IMsoComponentManager</name> <op:operator pos:line="534" pos:column="38">*</op:operator><op:operator pos:line="534" pos:column="39">*</op:operator><name pos:line="534" pos:column="40">rgpicmExclude</name><op:operator pos:line="534" pos:column="53">,</op:operator> 
		<name pos:line="535" pos:column="17">DWORD</name> <name pos:line="535" pos:column="23">dwReserved</name><op:operator pos:line="535" pos:column="33">)</op:operator> <name pos:line="535" pos:column="35">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="537" pos:column="9">/* Notify component manager that component identified by dwComponentID
		(cookie returned from FRegisterComponent) is exiting the state
		identified by uStateID (a msocstateXXX value).  (For convenience when
		dealing with sub CompMgrs, the host can call this method passing 0 for
		dwComponentID.)
		uContext, cpicmExclude, and rgpicmExclude are as they are in 
		OnComponentEnterState.
		Component manager	should notify all appropriate interested components
		(taking into account uContext, cpicmExclude, rgpicmExclude) via
		IMsoComponent::OnEnterState (see "Comments on State Contexts", above). 
		Component Manager should also take appropriate action depending on
		the value of uStateID (see msocstate comments, above).
		Return TRUE if, at the end of this call, the state is still in effect
		at the root of this component manager's state context
		(because the host or some other component is still in the state),
		otherwise return FALSE (ie. return what FInState would return).
		Caller can normally ignore the return value.
		
		Note: n calls to this method are symmetric with n calls to 
		OnComponentEnterState (see OnComponentEnterState comments, above). */</comment>
	<macro><name pos:line="557" pos:column="9">MSOMETHOD_</name><argument_list pos:line="557" pos:column="19">(<argument pos:line="557" pos:column="20">BOOL</argument>, <argument pos:line="557" pos:column="26">FOnComponentExitState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="557" pos:column="49">(</op:operator><name pos:line="557" pos:column="50">THIS_</name> 
		<name pos:line="558" pos:column="17">DWORD_PTR</name> <name pos:line="558" pos:column="27">dwComponentID</name><op:operator pos:line="558" pos:column="40">,</op:operator> 
		<name pos:line="559" pos:column="17">ULONG</name> <name pos:line="559" pos:column="23">uStateID</name><op:operator pos:line="559" pos:column="31">,</op:operator> 
		<name pos:line="560" pos:column="17">ULONG</name> <name pos:line="560" pos:column="23">uContext</name><op:operator pos:line="560" pos:column="31">,</op:operator>
		<name pos:line="561" pos:column="17">ULONG</name> <name pos:line="561" pos:column="23">cpicmExclude</name><op:operator pos:line="561" pos:column="35">,</op:operator>
		<name pos:line="562" pos:column="17">IMsoComponentManager</name> <op:operator pos:line="562" pos:column="38">*</op:operator><op:operator pos:line="562" pos:column="39">*</op:operator><name pos:line="562" pos:column="40">rgpicmExclude</name><op:operator pos:line="562" pos:column="53">)</op:operator> <name pos:line="562" pos:column="55">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="564" pos:column="9">/* Return TRUE if the state identified by uStateID (a msocstateXXX value)
		is in effect at the root of this component manager's state context, 
		FALSE otherwise (see "Comments on State Contexts", above).
		pvoid is reserved for future use and should be NULL. */</comment>
	<macro><name pos:line="568" pos:column="9">MSOMETHOD_</name><argument_list pos:line="568" pos:column="19">(<argument pos:line="568" pos:column="20">BOOL</argument>, <argument pos:line="568" pos:column="26">FInState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="568" pos:column="36">(</op:operator><name pos:line="568" pos:column="37">THIS_</name> <name pos:line="568" pos:column="43">ULONG</name> <name pos:line="568" pos:column="49">uStateID</name><op:operator pos:line="568" pos:column="57">,</op:operator> <name pos:line="568" pos:column="59">void</name> <op:operator pos:line="568" pos:column="64">*</op:operator><name pos:line="568" pos:column="65">pvoid</name><op:operator pos:line="568" pos:column="70">)</op:operator> <name pos:line="568" pos:column="72">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="570" pos:column="9">/* Called periodically by a component during IMsoComponent::FDoIdle.
		Return TRUE if component can continue its idle time processing, 
		FALSE if not (in which case component returns from FDoIdle.) */</comment>
	<macro><name pos:line="573" pos:column="9">MSOMETHOD_</name><argument_list pos:line="573" pos:column="19">(<argument pos:line="573" pos:column="20">BOOL</argument>, <argument pos:line="573" pos:column="26">FContinueIdle</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="573" pos:column="41">(</op:operator><name pos:line="573" pos:column="42">THIS</name><op:operator pos:line="573" pos:column="46">)</op:operator> <name pos:line="573" pos:column="48">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="575" pos:column="9">/* Component identified by dwComponentID (cookie returned from 
		FRegisterComponent) wishes to push a message loop for reason uReason.
		uReason is one the values from the msoloop enumeration (above).
		pvLoopData is data private to the component.
		The component manager should push its message loop, 
		calling IMsoComponent::FContinueMessageLoop(uReason, pvLoopData)
		during each loop iteration (see IMsoComponent::FContinueMessageLoop
		comments).  When IMsoComponent::FContinueMessageLoop returns FALSE, the
		component manager terminates the loop.
		Returns TRUE if component manager terminates loop because component
		told it to (by returning FALSE from IMsoComponent::FContinueMessageLoop),
		FALSE if it had to terminate the loop for some other reason.  In the 
		latter case, component should perform any necessary action (such as 
		cleanup). */</comment>
	<macro><name pos:line="589" pos:column="9">MSOMETHOD_</name><argument_list pos:line="589" pos:column="19">(<argument pos:line="589" pos:column="20">BOOL</argument>, <argument pos:line="589" pos:column="26">FPushMessageLoop</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="589" pos:column="44">(</op:operator><name pos:line="589" pos:column="45">THIS_</name> 
		<name pos:line="590" pos:column="17">DWORD_PTR</name> <name pos:line="590" pos:column="27">dwComponentID</name><op:operator pos:line="590" pos:column="40">,</op:operator> <name pos:line="590" pos:column="42">ULONG</name> <name pos:line="590" pos:column="48">uReason</name><op:operator pos:line="590" pos:column="55">,</op:operator> <name pos:line="590" pos:column="57">void</name> <op:operator pos:line="590" pos:column="62">*</op:operator><name pos:line="590" pos:column="63">pvLoopData</name><op:operator pos:line="590" pos:column="73">)</op:operator> <name pos:line="590" pos:column="75">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="592" pos:column="9">/* Cause the component manager to create a "sub" component manager, which
		will be one of its children in the hierarchical tree of component
		managers used to maintiain state contexts (see "Comments on State
		Contexts", above).
		piunkOuter is the controlling unknown (can be NULL), riid is the
		desired IID, and *ppvObj returns	the created sub component manager.
		piunkServProv (can be NULL) is a ptr to an object supporting
		IServiceProvider interface to which the created sub component manager
		will delegate its IMsoComponentManager::QueryService calls. 
		(see objext.h or docobj.h for definition of IServiceProvider).
		Returns TRUE if successful. */</comment>
	<macro><name pos:line="603" pos:column="9">MSOMETHOD_</name><argument_list pos:line="603" pos:column="19">(<argument pos:line="603" pos:column="20">BOOL</argument>, <argument pos:line="603" pos:column="26">FCreateSubComponentManager</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="603" pos:column="54">(</op:operator><name pos:line="603" pos:column="55">THIS_</name> 
		<name pos:line="604" pos:column="17">IUnknown</name> <op:operator pos:line="604" pos:column="26">*</op:operator><name pos:line="604" pos:column="27">piunkOuter</name><op:operator pos:line="604" pos:column="37">,</op:operator> 
		<name pos:line="605" pos:column="17">IUnknown</name> <op:operator pos:line="605" pos:column="26">*</op:operator><name pos:line="605" pos:column="27">piunkServProv</name><op:operator pos:line="605" pos:column="40">,</op:operator>
		<name pos:line="606" pos:column="17">REFIID</name> <name pos:line="606" pos:column="24">riid</name><op:operator pos:line="606" pos:column="28">,</op:operator> 
		<name pos:line="607" pos:column="17">void</name> <op:operator pos:line="607" pos:column="22">*</op:operator><op:operator pos:line="607" pos:column="23">*</op:operator><name pos:line="607" pos:column="24">ppvObj</name><op:operator pos:line="607" pos:column="30">)</op:operator> <name pos:line="607" pos:column="32">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="609" pos:column="9">/* Return in *ppicm an AddRef'ed ptr to this component manager's parent
		in the hierarchical tree of component managers used to maintain state
		contexts (see "Comments on State	Contexts", above).
		Returns TRUE if the parent is returned, FALSE if no parent exists or
		some error occurred. */</comment>
	<macro><name pos:line="614" pos:column="9">MSOMETHOD_</name><argument_list pos:line="614" pos:column="19">(<argument pos:line="614" pos:column="20">BOOL</argument>, <argument pos:line="614" pos:column="26">FGetParentComponentManager</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="614" pos:column="54">(</op:operator><name pos:line="614" pos:column="55">THIS_</name> 
		<name pos:line="615" pos:column="17">IMsoComponentManager</name> <op:operator pos:line="615" pos:column="38">*</op:operator><op:operator pos:line="615" pos:column="39">*</op:operator><name pos:line="615" pos:column="40">ppicm</name><op:operator pos:line="615" pos:column="45">)</op:operator> <name pos:line="615" pos:column="47">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="617" pos:column="9">/* Return in *ppic an AddRef'ed ptr to the current active or tracking
		component (as indicated by dwgac (a msogacXXX value)), and
		its registration information in *pcrinfo.  ppic and/or pcrinfo can be
		NULL if caller is not interested these values.  If pcrinfo is not NULL,
		caller should set pcrinfo-&gt;cbSize before calling this method.
		Returns TRUE if the component indicated by dwgac exists, FALSE if no 
		such component exists or some error occurred.
		dwReserved is reserved for future use and should be zero. */</comment>
	<macro><name pos:line="625" pos:column="9">MSOMETHOD_</name><argument_list pos:line="625" pos:column="19">(<argument pos:line="625" pos:column="20">BOOL</argument>, <argument pos:line="625" pos:column="26">FGetActiveComponent</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="625" pos:column="47">(</op:operator><name pos:line="625" pos:column="48">THIS_</name> 
		<name pos:line="626" pos:column="17">DWORD</name> <name pos:line="626" pos:column="23">dwgac</name><op:operator pos:line="626" pos:column="28">,</op:operator> 
		<name pos:line="627" pos:column="17">IMsoComponent</name> <op:operator pos:line="627" pos:column="31">*</op:operator><op:operator pos:line="627" pos:column="32">*</op:operator><name pos:line="627" pos:column="33">ppic</name><op:operator pos:line="627" pos:column="37">,</op:operator> 
		<name pos:line="628" pos:column="17">MSOCRINFO</name> <op:operator pos:line="628" pos:column="27">*</op:operator><name pos:line="628" pos:column="28">pcrinfo</name><op:operator pos:line="628" pos:column="35">,</op:operator>
		<name pos:line="629" pos:column="17">DWORD</name> <name pos:line="629" pos:column="23">dwReserved</name><op:operator pos:line="629" pos:column="33">)</op:operator> <name pos:line="629" pos:column="35">PURE</name></expr>;</expr_stmt>
	}</block><empty_stmt pos:line="630" pos:column="10">;</empty_stmt>


<comment type="block" format="doxygen" pos:line="633" pos:column="1">/****************************************************************************
	Defines the IMsoStdComponentMgr interface

	IMsoStdComponentMgr is an interface exposed by the office supplied
	standard component manager, created by MsoFCreateStdComponentMgr.
	The host application uses this interface to communicate directly with
	the standard component manager and indirectly with registered components.
	By making appropriate calls to this interface and implementing
	IMsoComponentHost the host can avoid implementing its own 
	IMsoComponentManager interface.
****************************************************************************/</comment>
<cpp:undef pos:line="644" pos:column="1">#<cpp:directive pos:line="644" pos:column="2">undef</cpp:directive>  <name pos:line="644" pos:column="9">INTERFACE</name></cpp:undef>
<cpp:define pos:line="645" pos:column="1">#<cpp:directive pos:line="645" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="645" pos:column="9">INTERFACE</name></cpp:macro>  <cpp:value pos:line="645" pos:column="20">IMsoStdComponentMgr</cpp:value></cpp:define>

<macro><name pos:line="647" pos:column="1">DECLARE_INTERFACE_</name><argument_list pos:line="647" pos:column="19">(<argument pos:line="647" pos:column="20">IMsoStdComponentMgr</argument>, <argument pos:line="647" pos:column="41">IUnknown</argument>)</argument_list></macro>
	<block pos:line="648" pos:column="9">{
	<function_decl><type><name pos:line="649" pos:column="9">BEGIN_MSOINTERFACE</name>
	<comment type="line" pos:line="650" pos:column="9">// *** IUnknown methods ***</comment>
	<name pos:line="651" pos:column="9">MSOMETHOD</name></type>(<name pos:line="651" pos:column="19">QueryInterface</name>) <parameter_list pos:line="651" pos:column="35">(<param><decl><type><name pos:line="651" pos:column="36">THIS_</name> <name pos:line="651" pos:column="42">REFIID</name></type> <name pos:line="651" pos:column="49">riid</name></decl></param>, <param><decl><type><name pos:line="651" pos:column="55">void</name> <type:modifier pos:line="651" pos:column="60">*</type:modifier><type:modifier pos:line="651" pos:column="61">*</type:modifier></type><name pos:line="651" pos:column="62">ppvObj</name></decl></param>)</parameter_list> <name pos:line="651" pos:column="70">PURE</name>;</function_decl>
	<macro><name pos:line="652" pos:column="9">MSOMETHOD_</name><argument_list pos:line="652" pos:column="19">(<argument pos:line="652" pos:column="20">ULONG</argument>, <argument pos:line="652" pos:column="27">AddRef</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="652" pos:column="35">(</op:operator><name pos:line="652" pos:column="36">THIS</name><op:operator pos:line="652" pos:column="40">)</op:operator> <name pos:line="652" pos:column="42">PURE</name></expr>;</expr_stmt>
	<macro><name pos:line="653" pos:column="9">MSOMETHOD_</name><argument_list pos:line="653" pos:column="19">(<argument pos:line="653" pos:column="20">ULONG</argument>, <argument pos:line="653" pos:column="27">Release</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="653" pos:column="36">(</op:operator><name pos:line="653" pos:column="37">THIS</name><op:operator pos:line="653" pos:column="41">)</op:operator> <name pos:line="653" pos:column="43">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="655" pos:column="9">/* Standard FDebugMessage method.
	   Since IMsoStdComponentMgr is a reference counted interface, 
	   MsoDWGetChkMemCounter is used when processing the 
	   msodmWriteBe message. */</comment>
	<decl_stmt><decl><type><name pos:line="659" pos:column="9">MSODEBUGMETHOD</name></type>

	<comment type="block" pos:line="661" pos:column="9">/* Set *pchostinfo as the host info.  Can be called multiple times.
		Returns TRUE if successful. */</comment>
	<name pos:line="663" pos:column="9">MSOMETHOD_</name><argument_list pos:line="663" pos:column="19">(<argument><expr><name pos:line="663" pos:column="20">BOOL</name></expr></argument>, <argument><expr><name pos:line="663" pos:column="26">FSetHostInfo</name></expr></argument>)</argument_list> <argument_list pos:line="663" pos:column="40">(<argument><expr><name pos:line="663" pos:column="41">THIS_</name> 
		const <name pos:line="664" pos:column="23">MSOCHOSTINFO</name> <op:operator pos:line="664" pos:column="36">*</op:operator><name pos:line="664" pos:column="37">pchostinfo</name></expr></argument>)</argument_list> <name pos:line="664" pos:column="49">PURE</name></decl>;</decl_stmt>

	<comment type="block" pos:line="666" pos:column="9">/* Host calls this method to give the active component a chance to
		process messages before they are translated and dispatched.
		The host need not call this method if no component is active.
		When this method is called on message pMsg, StdComponentMgr in turn 
		calls IMsoComponent::FPreTranslateMessage on the active component if
		its registration info indicates that it is interested.  
		Returns TRUE if message is consumed, in which case the host should
		perform no further processing on the message.  
		Returns FALSE otherwise. */</comment>
	<macro><name pos:line="675" pos:column="9">MSOMETHOD_</name><argument_list pos:line="675" pos:column="19">(<argument pos:line="675" pos:column="20">BOOL</argument>, <argument pos:line="675" pos:column="26">FPreTranslateMessage</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="675" pos:column="48">(</op:operator><name pos:line="675" pos:column="49">THIS_</name> <name pos:line="675" pos:column="55">MSG</name> <op:operator pos:line="675" pos:column="59">*</op:operator><name pos:line="675" pos:column="60">pMsg</name><op:operator pos:line="675" pos:column="64">)</op:operator> <name pos:line="675" pos:column="66">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="677" pos:column="9">/* Called by host to notify StdComponentMgr that one of the host's windows
		has been activated.  This causes the current active component to lose
		its active status.  However, host should not assume that the component
		is no longer active until 
		IMsoComponentHost::OnComponentActivate(NULL) is called.
		This method fails if a component is already Exclusively Active.
		In this case, FALSE is returned and SetLastError is set to 
		msoerrACompIsXActive (host usually need not take any special action
		in this case).
		Returns TRUE if successful. */</comment>
	<macro><name pos:line="687" pos:column="9">MSOMETHOD_</name><argument_list pos:line="687" pos:column="19">(<argument pos:line="687" pos:column="20">BOOL</argument>, <argument pos:line="687" pos:column="26">FOnHostActivate</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="687" pos:column="43">(</op:operator><name pos:line="687" pos:column="44">THIS</name><op:operator pos:line="687" pos:column="48">)</op:operator> <name pos:line="687" pos:column="50">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="689" pos:column="9">/* Called by host to notify StdComponentMgr that host is entering the 
		state identified by uStateID (a msocstateXXX value).
		StdComponentMgr in turn notifies all interested components excluding
		those within the context of a CompMgr appearing in rgpicmExclude (an
		array (can be NULL) of cpicmExclude CompMgrs (can include root CompMgr 
		and/or sub CompMgrs)).
		dwReserved is reserved for future use and should be zero.
		Note: Calls to this method are symmetric with FOnHostExitState calls.
		That is, if n OnHostEnterState calls are made, the host is
		considered to be in the state until n FOnHostExitState calls are
		made. */</comment>
	<macro><name pos:line="700" pos:column="9">MSOMETHOD_</name><argument_list pos:line="700" pos:column="19">(<argument pos:line="700" pos:column="20">void</argument>, <argument pos:line="700" pos:column="26">OnHostEnterState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="700" pos:column="44">(</op:operator><name pos:line="700" pos:column="45">THIS_</name> 
		<name pos:line="701" pos:column="17">ULONG</name> <name pos:line="701" pos:column="23">uStateID</name><op:operator pos:line="701" pos:column="31">,</op:operator> 
		<name pos:line="702" pos:column="17">ULONG</name> <name pos:line="702" pos:column="23">cpicmExclude</name><op:operator pos:line="702" pos:column="35">,</op:operator>
		<name pos:line="703" pos:column="17">IMsoComponentManager</name> <op:operator pos:line="703" pos:column="38">*</op:operator><op:operator pos:line="703" pos:column="39">*</op:operator><name pos:line="703" pos:column="40">rgpicmExclude</name><op:operator pos:line="703" pos:column="53">,</op:operator> 
		<name pos:line="704" pos:column="17">DWORD</name> <name pos:line="704" pos:column="23">dwReserved</name><op:operator pos:line="704" pos:column="33">)</op:operator> <name pos:line="704" pos:column="35">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="706" pos:column="9">/* Called by host to notify StdComponentMgr that host is exiting the state 
		identified by uStateID (a msocstateXXX value).  
		StdComponentMgr in turn notifies  all interested components excluding
		those within the context of a CompMgr appearing in rgpicmExclude (an
		array (can be NULL) of cpicmExclude CompMgrs (can include root CompMgr 
		and/or sub CompMgrs)).
		Returns TRUE if the state is still in effect at the end of this call
		(because some component is still in the state), otherwise returns 
		FALSE (ie. returns what FInState would return).  Caller can normally
		ignore the return value.
		Note: n calls to this method are symmetric with n calls to 
		OnHostEnterState (see OnHostEnterState comments, above). */</comment>
	<macro><name pos:line="718" pos:column="9">MSOMETHOD_</name><argument_list pos:line="718" pos:column="19">(<argument pos:line="718" pos:column="20">BOOL</argument>, <argument pos:line="718" pos:column="26">FOnHostExitState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="718" pos:column="44">(</op:operator><name pos:line="718" pos:column="45">THIS_</name> 
		<name pos:line="719" pos:column="17">ULONG</name> <name pos:line="719" pos:column="23">uStateID</name><op:operator pos:line="719" pos:column="31">,</op:operator>
		<name pos:line="720" pos:column="17">ULONG</name> <name pos:line="720" pos:column="23">cpicmExclude</name><op:operator pos:line="720" pos:column="35">,</op:operator>
		<name pos:line="721" pos:column="17">IMsoComponentManager</name> <op:operator pos:line="721" pos:column="38">*</op:operator><op:operator pos:line="721" pos:column="39">*</op:operator><name pos:line="721" pos:column="40">rgpicmExclude</name><op:operator pos:line="721" pos:column="53">)</op:operator> <name pos:line="721" pos:column="55">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="723" pos:column="9">/* Returns TRUE if state identified by uStateID (a value from msocstate
		enumeration) is in effect, FALSE otherwise.
		pvoid is reserved for future use and should be NULL. */</comment>
	<macro><name pos:line="726" pos:column="9">MSOMETHOD_</name><argument_list pos:line="726" pos:column="19">(<argument pos:line="726" pos:column="20">BOOL</argument>, <argument pos:line="726" pos:column="26">FInState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="726" pos:column="36">(</op:operator><name pos:line="726" pos:column="37">THIS_</name> <name pos:line="726" pos:column="43">ULONG</name> <name pos:line="726" pos:column="49">uStateID</name><op:operator pos:line="726" pos:column="57">,</op:operator> <name pos:line="726" pos:column="59">void</name> <op:operator pos:line="726" pos:column="64">*</op:operator><name pos:line="726" pos:column="65">pvoid</name><op:operator pos:line="726" pos:column="70">)</op:operator> <name pos:line="726" pos:column="72">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="728" pos:column="9">/* Called by host to give registered components the chance to perform idle
		time tasks of the type indicated by grfidlef, a group of bit flags
		taken from the enumeration of msoidlef values (above).
		During a component tracking operation, StdComponentMgr only gives the
		tracking component idle time.
		Returns TRUE if any component needs more time to perform the idle time
		tasks, FALSE otherwise. */</comment>
	<macro><name pos:line="735" pos:column="9">MSOMETHOD_</name><argument_list pos:line="735" pos:column="19">(<argument pos:line="735" pos:column="20">BOOL</argument>, <argument pos:line="735" pos:column="26">FDoIdle</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="735" pos:column="35">(</op:operator><name pos:line="735" pos:column="36">THIS_</name> <name pos:line="735" pos:column="42">MSOIDLE</name> <name pos:line="735" pos:column="50">grfidlef</name><op:operator pos:line="735" pos:column="58">)</op:operator> <name pos:line="735" pos:column="60">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="737" pos:column="9">/* Called by host just before it enters the 'wait mode' resulting from a
		call to WaitMessage, GetMessage, or MsgWaitForMultipleObjects.  Such a
		'wait mode' would prevent any components from receiving periodic idle 
		time.  If any registered components need periodic idle time, StdCompMgr
		starts an appropriate timer.  The resulting WM_TIMER message will cause
		the host	to exit the 'wait mode', allowing the processing of periodic 
		idle time tasks when the host calls IMsoStdComponentMgr::FDoIdle. */</comment>
	<macro><name pos:line="744" pos:column="9">MSOMETHOD_</name><argument_list pos:line="744" pos:column="19">(<argument pos:line="744" pos:column="20">void</argument>, <argument pos:line="744" pos:column="26">OnWaitForMessage</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="744" pos:column="44">(</op:operator><name pos:line="744" pos:column="45">THIS</name><op:operator pos:line="744" pos:column="49">)</op:operator> <name pos:line="744" pos:column="51">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="746" pos:column="9">/* Called by host during each iteration of a message loop that a component 
		pushed.
		This method is to be called after peeking the next message in the queue
		(via PeekMessage) but before the message is removed from the queue.
		The peeked message is passed in the pMsgPeeked param (NULL if no 
		message is in the queue).  If this method is additionally called when
		the next message has already been removed from the queue, pMsgPeeked 
		should be passed as NULL.
		StdComponentMgr in turn calls IMsoComponent::FContinueMessageLoop
		on the component, and returns the value returned by that call. 
		Returns TRUE if the message loop should continue, FALSE otherwise.
		If FALSE is returned, the loop should be terminated without removing
		pMsgPeeked from the queue. */</comment>
	<macro><name pos:line="759" pos:column="9">MSOMETHOD_</name><argument_list pos:line="759" pos:column="19">(<argument pos:line="759" pos:column="20">BOOL</argument>, <argument pos:line="759" pos:column="26">FContinueMessageLoop</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="759" pos:column="48">(</op:operator><name pos:line="759" pos:column="49">THIS_</name> <name pos:line="759" pos:column="55">MSG</name> <op:operator pos:line="759" pos:column="59">*</op:operator><name pos:line="759" pos:column="60">pMsgPeeked</name><op:operator pos:line="759" pos:column="70">)</op:operator> <name pos:line="759" pos:column="72">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="761" pos:column="9">/* Called by host to determine if all registered components can terminate.
		StdComponentMgr asks each component whether it can terminate via
		IMsoComponent::FQueryTerminate(fPromptUser).  If all components
		return TRUE, then StdComponentMgr returns TRUE.  If any one of the
		components returns FALSE, then StdComponentMgr immediately returns
		FALSE without asking any more components. */</comment>
	<macro><name pos:line="767" pos:column="9">MSOMETHOD_</name><argument_list pos:line="767" pos:column="19">(<argument pos:line="767" pos:column="20">BOOL</argument>, <argument pos:line="767" pos:column="26">FQueryTerminate</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="767" pos:column="43">(</op:operator><name pos:line="767" pos:column="44">THIS_</name> <name pos:line="767" pos:column="50">BOOL</name> <name pos:line="767" pos:column="55">fPromptUser</name><op:operator pos:line="767" pos:column="66">)</op:operator> <name pos:line="767" pos:column="68">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="769" pos:column="9">/* Called by host to terminate the StdComponentMgr.
		If fRevoke is TRUE and StdComponentMgr is registered as the current
		thread's component manager, this registration is revoked.
		Then, for each registered component, StdComponentMgr calls 
		IMsoComponent::Terminate and revokes its registration. */</comment>
	<macro><name pos:line="774" pos:column="9">MSOMETHOD_</name><argument_list pos:line="774" pos:column="19">(<argument pos:line="774" pos:column="20">void</argument>, <argument pos:line="774" pos:column="26">Terminate</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="774" pos:column="37">(</op:operator><name pos:line="774" pos:column="38">THIS_</name> <name pos:line="774" pos:column="44">BOOL</name> <name pos:line="774" pos:column="49">fRevoke</name><op:operator pos:line="774" pos:column="56">)</op:operator> <name pos:line="774" pos:column="58">PURE</name></expr>;</expr_stmt>
	}</block><empty_stmt pos:line="775" pos:column="10">;</empty_stmt>


<comment type="block" format="doxygen" pos:line="778" pos:column="1">/****************************************************************************
	Defines the IMsoComponentHost interface

	IMsoComponentHost is a host implemented interface that the standard
	component manager uses to communicate with the host.  By implementing
	this interface and making use of the standard component manager, the host
	can avoid having to implement its own component manager. 
****************************************************************************/</comment>
<cpp:undef pos:line="786" pos:column="1">#<cpp:directive pos:line="786" pos:column="2">undef</cpp:directive>  <name pos:line="786" pos:column="9">INTERFACE</name></cpp:undef>
<cpp:define pos:line="787" pos:column="1">#<cpp:directive pos:line="787" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="787" pos:column="9">INTERFACE</name></cpp:macro>  <cpp:value pos:line="787" pos:column="20">IMsoComponentHost</cpp:value></cpp:define>

<macro><name pos:line="789" pos:column="1">DECLARE_INTERFACE_</name><argument_list pos:line="789" pos:column="19">(<argument pos:line="789" pos:column="20">IMsoComponentHost</argument>, <argument pos:line="789" pos:column="39">IUnknown</argument>)</argument_list></macro>
	<block pos:line="790" pos:column="9">{
	<function_decl><type><name pos:line="791" pos:column="9">BEGIN_MSOINTERFACE</name>
	<comment type="line" pos:line="792" pos:column="9">// *** IUnknown methods ***</comment>
	<name pos:line="793" pos:column="9">MSOMETHOD</name></type>(<name pos:line="793" pos:column="19">QueryInterface</name>) <parameter_list pos:line="793" pos:column="35">(<param><decl><type><name pos:line="793" pos:column="36">THIS_</name> <name pos:line="793" pos:column="42">REFIID</name></type> <name pos:line="793" pos:column="49">riid</name></decl></param>, <param><decl><type><name pos:line="793" pos:column="55">void</name> <type:modifier pos:line="793" pos:column="60">*</type:modifier><type:modifier pos:line="793" pos:column="61">*</type:modifier></type><name pos:line="793" pos:column="62">ppvObj</name></decl></param>)</parameter_list> <name pos:line="793" pos:column="70">PURE</name>;</function_decl>
	<macro><name pos:line="794" pos:column="9">MSOMETHOD_</name><argument_list pos:line="794" pos:column="19">(<argument pos:line="794" pos:column="20">ULONG</argument>, <argument pos:line="794" pos:column="27">AddRef</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="794" pos:column="35">(</op:operator><name pos:line="794" pos:column="36">THIS</name><op:operator pos:line="794" pos:column="40">)</op:operator> <name pos:line="794" pos:column="42">PURE</name></expr>;</expr_stmt>
	<macro><name pos:line="795" pos:column="9">MSOMETHOD_</name><argument_list pos:line="795" pos:column="19">(<argument pos:line="795" pos:column="20">ULONG</argument>, <argument pos:line="795" pos:column="27">Release</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="795" pos:column="36">(</op:operator><name pos:line="795" pos:column="37">THIS</name><op:operator pos:line="795" pos:column="41">)</op:operator> <name pos:line="795" pos:column="43">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="797" pos:column="9">/* StdComponentMgr delegates calls to IMsoComponentManager::QueryService
		to the host by calling this method.
		Return in *ppvObj an implementation of interface iid for service
		guidService (same as IServiceProvider::QueryService).
		Return NOERROR if the requested service is supported, otherwise return
		NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE). */</comment>
	<function_decl><type><name pos:line="803" pos:column="9">MSOMETHOD</name></type>(<name pos:line="803" pos:column="19">QueryService</name>) <parameter_list pos:line="803" pos:column="33">(<param><decl><type><name pos:line="803" pos:column="34">THIS_</name>
		<name pos:line="804" pos:column="17">REFGUID</name></type> <name pos:line="804" pos:column="25">guidService</name></decl></param>, <param><decl><type><name pos:line="804" pos:column="38">REFIID</name></type> <name pos:line="804" pos:column="45">iid</name></decl></param>, <param><decl><type><name pos:line="804" pos:column="50">void</name> <type:modifier pos:line="804" pos:column="55">*</type:modifier><type:modifier pos:line="804" pos:column="56">*</type:modifier></type><name pos:line="804" pos:column="57">ppvObj</name></decl></param>)</parameter_list> <name pos:line="804" pos:column="65">PURE</name>;</function_decl>

	<comment type="block" pos:line="806" pos:column="9">/* Standard FDebugMessage method.
	   Since IMsoComponentHost is a reference counted interface, 
	   MsoDWGetChkMemCounter should be used when processing the 
	   msodmWriteBe message. */</comment>
	<decl_stmt><decl><type><name pos:line="810" pos:column="9">MSODEBUGMETHOD</name></type>

	<comment type="block" pos:line="812" pos:column="9">/* Called when component pic is activated (or should be treated as active
		by virtue of beginning a "tracking" operation 
		(see IMsoComponentManager::FSetTrackingComponent)).  
		pcrinfo contains component's registration information.  
		fTracking indicates whether the component is in tracking mode or not.
		If pic is NULL (in which case pcrinfo will be NULL), then this 
		indicates that no component is active.  
		When a component is active and its registration info indicates that it
		needs to process untranslated messages, the host must call 
		IMsoStdComponentMgr::FPreTranslateMessage for each appropriate message
		retrieved from the queue before processing it, so that the active 
		component gets a chance to process the message appropriately.
		(A simple host could avoid examining the component's registration info,
		 and simply call IMsoStdComponentMgr::FPreTranslateMessage for all
		 retrieved messages.)
		If the component is in tracking mode, as indicated by fTracking, then
		the host app should perform no idle time processing other than to give
		the tracking component idle time via IMsoStdComponentMgr::FDoIdle,
		until the tracking operation is completed (communicated to host via a
		subsequent call to OnComponentActivate with fTracking == FALSE).

		Additionally, if pic is nonNULL and fTracking is FALSE, then host 
		should check if pcrinfo-&gt;grfcrf has the ExclusiveActive or 
		ExclusiveBorderSpace bit set.  
		
		If ExclusiveBorderSpace bit is set, then host should hide its border
		space tools (toolbars, status bars, etc.) and not show them again until
		the host is reactivated.
		
		If ExclusiveActivation bit is set, then pic is being activated in
		"ExclusiveActive" mode.
		Host should retrieve the top frame window that is hosting pic 
		(via pic-&gt;HwndGetWindow(msocWindowFrameToplevel, 0)).  
		If this window is different from host's own top frame window, 
			host should disable its windows and do other things it would do
			when receiving OnComponentEnterState(msocstateModal, TRUE)
			notification. 
		Otherwise, 
			host should refuse to have its window activated by appropriately
			processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
		Host should remain in this state until the ExclusiveActive mode ends, 
		indicated by a future call to OnComponentActivate (with FALSE 
		fTracking) with ExclusiveActivation bit not set or NULL pcrinfo. */</comment>
	<name pos:line="855" pos:column="9">MSOMETHOD_</name><argument_list pos:line="855" pos:column="19">(<argument><expr><name pos:line="855" pos:column="20">void</name></expr></argument>, <argument><expr><name pos:line="855" pos:column="26">OnComponentActivate</name></expr></argument>)</argument_list> <argument_list pos:line="855" pos:column="47">(<argument><expr><name pos:line="855" pos:column="48">THIS_</name>
		<name pos:line="856" pos:column="17">IMsoComponent</name> <op:operator pos:line="856" pos:column="31">*</op:operator><name pos:line="856" pos:column="32">pic</name></expr></argument>, <argument><expr pos:line="856" pos:column="37">const <name pos:line="856" pos:column="43">MSOCRINFO</name> <op:operator pos:line="856" pos:column="53">*</op:operator><name pos:line="856" pos:column="54">pcrinfo</name></expr></argument>, <argument><expr><name pos:line="856" pos:column="63">BOOL</name> <name pos:line="856" pos:column="68">fTracking</name></expr></argument>)</argument_list> <name pos:line="856" pos:column="79">PURE</name></decl>;</decl_stmt>
	
	<comment type="block" pos:line="858" pos:column="9">/* Notify host that a component is entering or exiting (indicated by 
		fEnter) the state identified by uStateID (a msocstateXXX value).  
		Host should take action depending on value of uStateID (see msocstate
		comments, above). 
		
		Note: If n calls are made with TRUE fEnter, the host should consider
		the state to be in effect until n calls are made with FALSE fEnter.

		Note: Hosts should be aware that it is possible for this method to
		be called with FALSE fEnter more	times than it was called with TRUE 
		fEnter (so, for example, if host is maintaining a state counter
		(incremented when this method is called with TRUE fEnter, decremented
		when called with FALSE fEnter), the counter should not be decremented
		for FALSE fEnter if it is already at zero.)  */</comment>
	<macro><name pos:line="872" pos:column="9">MSOMETHOD_</name><argument_list pos:line="872" pos:column="19">(<argument pos:line="872" pos:column="20">void</argument>, <argument pos:line="872" pos:column="26">OnComponentEnterState</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="872" pos:column="49">(</op:operator><name pos:line="872" pos:column="50">THIS_</name>
		<name pos:line="873" pos:column="17">ULONG</name> <name pos:line="873" pos:column="23">uStateID</name><op:operator pos:line="873" pos:column="31">,</op:operator> <name pos:line="873" pos:column="33">BOOL</name> <name pos:line="873" pos:column="38">fEnter</name><op:operator pos:line="873" pos:column="44">)</op:operator> <name pos:line="873" pos:column="46">PURE</name></expr>;</expr_stmt>
	
	<comment type="block" pos:line="875" pos:column="9">/* Called periodically by StdComponentMgr during 
		IMsoStdComponentMgr::FDoIdle.
		Return TRUE if idle time processing can continue, FALSE if not. */</comment>
	<macro><name pos:line="878" pos:column="9">MSOMETHOD_</name><argument_list pos:line="878" pos:column="19">(<argument pos:line="878" pos:column="20">BOOL</argument>, <argument pos:line="878" pos:column="26">FContinueIdle</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="878" pos:column="41">(</op:operator><name pos:line="878" pos:column="42">THIS</name><op:operator pos:line="878" pos:column="46">)</op:operator> <name pos:line="878" pos:column="48">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="880" pos:column="9">/* Called by StdComponentMgr when a component wishes to push a message
		loop for reason uReason.
		uReason is one the values from the msoloop enumeration (above).
		The host should push its message loop, calling
		IMsoStdComponentMgr::FContinueMessageLoop during each loop iteration 
		(see IMsoStdComponentMgr::FContinueMessageLoop comments).
		When IMsoStdComponentMgr::FContinueMessageLoop returns FALSE, the host
		should terminate the loop.
		If host terminates the loop because StdComponentMgr told it to
		(by returning FALSE from IMsoStdComponentMgr::FContinueMessageLoop),
		host should return TRUE from this method.  If host had to terminate
		the loop for some other reason, it should return FALSE. */</comment>
	<macro><name pos:line="892" pos:column="9">MSOMETHOD_</name><argument_list pos:line="892" pos:column="19">(<argument pos:line="892" pos:column="20">BOOL</argument>, <argument pos:line="892" pos:column="26">FPushMessageLoop</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="892" pos:column="44">(</op:operator><name pos:line="892" pos:column="45">THIS_</name> <name pos:line="892" pos:column="51">ULONG</name> <name pos:line="892" pos:column="57">uReason</name><op:operator pos:line="892" pos:column="64">)</op:operator> <name pos:line="892" pos:column="66">PURE</name></expr>;</expr_stmt>
	}</block><empty_stmt pos:line="893" pos:column="10">;</empty_stmt>



<comment type="block" format="doxygen" pos:line="897" pos:column="1">/****************************************************************************
	Structures and constants for simple recording.
****************************************************************************/</comment>

<comment type="line" pos:line="901" pos:column="1">// Simple recorder context values passed to IMsoSimpleRecorder::FGetContext</comment>
<enum pos:line="902" pos:column="1">enum
	<block pos:line="903" pos:column="9">{
	<decl><name pos:line="904" pos:column="9">msosrctxCommandBars</name> <init pos:line="904" pos:column="29">= <expr><lit:literal type="number" pos:line="904" pos:column="31">0</lit:literal></expr></init></decl><op:operator pos:line="904" pos:column="32">,</op:operator>			<comment type="line" pos:line="904" pos:column="57">// pv will be the IMsoToolbarSet object</comment>
	<decl><name pos:line="905" pos:column="9">msosrctxEscher</name> <init pos:line="905" pos:column="24">= <expr><lit:literal type="number" pos:line="905" pos:column="26">1</lit:literal></expr></init></decl><op:operator pos:line="905" pos:column="27">,</op:operator>
	<decl><name pos:line="906" pos:column="9">msosrctxDrawing</name> <init pos:line="906" pos:column="25">= <expr><lit:literal type="number" pos:line="906" pos:column="27">2</lit:literal></expr></init></decl><op:operator pos:line="906" pos:column="28">,</op:operator>
	<decl><name pos:line="907" pos:column="9">msosrctxDrawingSelection</name> <init pos:line="907" pos:column="34">= <expr><lit:literal type="number" pos:line="907" pos:column="36">3</lit:literal></expr></init></decl><op:operator pos:line="907" pos:column="37">,</op:operator>
	<decl><name pos:line="908" pos:column="9">msosrctxDrawingSchemeColor</name> <init pos:line="908" pos:column="36">= <expr><lit:literal type="number" pos:line="908" pos:column="38">4</lit:literal></expr></init></decl><op:operator pos:line="908" pos:column="39">,</op:operator>
	<decl><name pos:line="909" pos:column="9">msosrctxDrawingDefault</name> <init pos:line="909" pos:column="32">= <expr><lit:literal type="number" pos:line="909" pos:column="34">5</lit:literal></expr></init></decl><op:operator pos:line="909" pos:column="35">,</op:operator>
	}</block>;</enum>

<comment type="block" format="doxygen" pos:line="912" pos:column="1">/****************************************************************************
	Defines the IMsoSimpleRecorder interface
****************************************************************************/</comment>
<cpp:undef pos:line="915" pos:column="1">#<cpp:directive pos:line="915" pos:column="2">undef</cpp:directive>  <name pos:line="915" pos:column="9">INTERFACE</name></cpp:undef>
<cpp:define pos:line="916" pos:column="1">#<cpp:directive pos:line="916" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="916" pos:column="9">INTERFACE</name></cpp:macro>  <cpp:value pos:line="916" pos:column="20">IMsoSimpleRecorder</cpp:value></cpp:define>

<macro><name pos:line="918" pos:column="1">DECLARE_INTERFACE_</name><argument_list pos:line="918" pos:column="19">(<argument pos:line="918" pos:column="20">IMsoSimpleRecorder</argument>, <argument pos:line="918" pos:column="40">IUnknown</argument>)</argument_list></macro>
<block pos:line="919" pos:column="1">{
	<function_decl><type><name pos:line="920" pos:column="9">BEGIN_MSOINTERFACE</name>
	<comment type="line" pos:line="921" pos:column="9">// *** IUnknown methods ***</comment>
	<name pos:line="922" pos:column="9">MSOMETHOD</name></type>(<name pos:line="922" pos:column="19">QueryInterface</name>) <parameter_list pos:line="922" pos:column="35">(<param><decl><type><name pos:line="922" pos:column="36">THIS_</name> <name pos:line="922" pos:column="42">REFIID</name></type> <name pos:line="922" pos:column="49">riid</name></decl></param>, <param><decl><type><name pos:line="922" pos:column="55">void</name> <type:modifier pos:line="922" pos:column="60">*</type:modifier><type:modifier pos:line="922" pos:column="61">*</type:modifier></type><name pos:line="922" pos:column="62">ppvObj</name></decl></param>)</parameter_list> <name pos:line="922" pos:column="70">PURE</name>;</function_decl>
	<macro><name pos:line="923" pos:column="9">MSOMETHOD_</name><argument_list pos:line="923" pos:column="19">(<argument pos:line="923" pos:column="20">ULONG</argument>, <argument pos:line="923" pos:column="27">AddRef</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="923" pos:column="35">(</op:operator><name pos:line="923" pos:column="36">THIS</name><op:operator pos:line="923" pos:column="40">)</op:operator> <name pos:line="923" pos:column="42">PURE</name></expr>;</expr_stmt>
	<macro><name pos:line="924" pos:column="9">MSOMETHOD_</name><argument_list pos:line="924" pos:column="19">(<argument pos:line="924" pos:column="20">ULONG</argument>, <argument pos:line="924" pos:column="27">Release</argument>)</argument_list></macro> <expr_stmt><expr><op:operator pos:line="924" pos:column="36">(</op:operator><name pos:line="924" pos:column="37">THIS</name><op:operator pos:line="924" pos:column="41">)</op:operator> <name pos:line="924" pos:column="43">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="926" pos:column="9">/* Standard FDebugMessage method.
	   Since IMsoSimpleRecorder is a reference counted interface, 
	   MsoDWGetChkMemCounter is used when processing the 
	   msodmWriteBe message. */</comment>
	<decl_stmt><decl><type><name pos:line="930" pos:column="9">MSODEBUGMETHOD</name></type>

	<comment type="block" pos:line="932" pos:column="9">/* Returns a string specifying the position of the requested context
	   in the host's object model.  The context is specified by msosrctx, 
	   and the additional value pv if needed to disambiguate different 
	   objects of that type.  The string buffer should have room for
	   255 characters.  Returns TRUE if successful, FALSE otherwise. */</comment>
	<name pos:line="937" pos:column="9">MSOMETHOD_</name><argument_list pos:line="937" pos:column="19">(<argument><expr><name pos:line="937" pos:column="20">BOOL</name></expr></argument>, <argument><expr><name pos:line="937" pos:column="26">FGetContext</name></expr></argument>)</argument_list><argument_list pos:line="937" pos:column="38">(<argument><expr><name pos:line="937" pos:column="39">THIS_</name> <name pos:line="937" pos:column="45">int</name> <name pos:line="937" pos:column="49">msosrctx</name></expr></argument>, <argument><expr><name pos:line="937" pos:column="59">void</name> <op:operator pos:line="937" pos:column="64">*</op:operator><name pos:line="937" pos:column="65">pv</name></expr></argument>, <argument><expr><name pos:line="937" pos:column="69">WCHAR</name> <op:operator pos:line="937" pos:column="75">*</op:operator><name pos:line="937" pos:column="76">wz</name></expr></argument>)</argument_list> <name pos:line="937" pos:column="80">PURE</name></decl>;</decl_stmt>

	<comment type="block" pos:line="939" pos:column="9">/* Asks the host to record a line of text at the current position
	   in the recorder stream.  Returns TRUE if the line was successfully
	   recorded, FALSE otherwise. */</comment>
	<macro><name pos:line="942" pos:column="9">MSOMETHOD_</name><argument_list pos:line="942" pos:column="19">(<argument pos:line="942" pos:column="20">BOOL</argument>, <argument pos:line="942" pos:column="26">FRecordLine</argument>)</argument_list></macro><expr_stmt><expr><op:operator pos:line="942" pos:column="38">(</op:operator><name pos:line="942" pos:column="39">THIS_</name> <name pos:line="942" pos:column="45">WCHAR</name> <op:operator pos:line="942" pos:column="51">*</op:operator><name pos:line="942" pos:column="52">wz</name><op:operator pos:line="942" pos:column="54">)</op:operator> <name pos:line="942" pos:column="56">PURE</name></expr>;</expr_stmt>

	<comment type="block" pos:line="944" pos:column="9">/* Returns TRUE if the host currently has recording turned on, and
	   FALSE otherwise. */</comment>
	<macro><name pos:line="946" pos:column="9">MSOMETHOD_</name><argument_list pos:line="946" pos:column="19">(<argument pos:line="946" pos:column="20">BOOL</argument>, <argument pos:line="946" pos:column="26">FRecording</argument>)</argument_list></macro><expr_stmt><expr><op:operator pos:line="946" pos:column="37">(</op:operator><name pos:line="946" pos:column="38">THIS</name><op:operator pos:line="946" pos:column="42">)</op:operator> <name pos:line="946" pos:column="44">PURE</name></expr>;</expr_stmt>
}</block><empty_stmt pos:line="947" pos:column="2">;</empty_stmt>



<comment type="block" format="doxygen" pos:line="951" pos:column="1">/****************************************************************************
	Global DLL API's
****************************************************************************/</comment>

<comment type="block" pos:line="955" pos:column="1">/* Called by host application to register picm as the component manager for
	the calling thread.  Standard reference counting rules apply.  
	picm can be NULL, indicating that the currently	registered component 
	manager should be revoked.
	If there is a previously registered component manager it is Released.
	Returns TRUE if successful. */</comment>
<macro><name pos:line="961" pos:column="1">MSOAPI_</name><argument_list pos:line="961" pos:column="8">(<argument pos:line="961" pos:column="9">BOOL</argument>)</argument_list></macro> <expr_stmt><expr><call><name pos:line="961" pos:column="15">MsoFSetComponentManager</name><argument_list pos:line="961" pos:column="38">(<argument><expr><name pos:line="961" pos:column="39">IMsoComponentManager</name> <op:operator pos:line="961" pos:column="60">*</op:operator><name pos:line="961" pos:column="61">picm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" pos:line="963" pos:column="1">/* Return in *ppicm an AddRef'ed pointer to the currently registered
	component manager for the calling thread.
	Returns TRUE if successful. */</comment>
<macro><name pos:line="966" pos:column="1">MSOAPI_</name><argument_list pos:line="966" pos:column="8">(<argument pos:line="966" pos:column="9">BOOL</argument>)</argument_list></macro> <expr_stmt><expr><call><name pos:line="966" pos:column="15">MsoFGetComponentManager</name><argument_list pos:line="966" pos:column="38">(<argument><expr><name pos:line="966" pos:column="39">IMsoComponentManager</name> <op:operator pos:line="966" pos:column="60">*</op:operator><op:operator pos:line="966" pos:column="61">*</op:operator><name pos:line="966" pos:column="62">ppicm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" pos:line="968" pos:column="1">/* Create an object which has the Office supplied standard implementation
	of IMsoStdComponentMgr and IMsoComponentManager, and return it in *ppvObj.
	piUnkOuter is the controlling unknown for aggregation (can be NULL).
	pich (cannot be NULL) is the pointer to the IMsoComponentHost
	that will use the object.
	riid is the id of the desired interface.
	If fRegister is TRUE, the created object is registered as the calling
	thread's component manager.
	Returns TRUE if successful. */</comment>
<macro><name pos:line="977" pos:column="1">MSOAPI_</name><argument_list pos:line="977" pos:column="8">(<argument pos:line="977" pos:column="9">BOOL</argument>)</argument_list></macro> <macro><name pos:line="977" pos:column="15">MsoFCreateStdComponentManager</name><argument_list pos:line="977" pos:column="44">(
	<argument pos:line="978" pos:column="9">IUnknown *piUnkOuter</argument>,
	<argument pos:line="979" pos:column="9">IMsoComponentHost *pich</argument>,
	<argument pos:line="980" pos:column="9">BOOL fRegister</argument>,
	<argument pos:line="981" pos:column="9">REFIID riid</argument>,
	<argument pos:line="982" pos:column="9">void **ppvObj</argument>)</argument_list></macro><empty_stmt pos:line="982" pos:column="23">;</empty_stmt>

<cpp:endif pos:line="984" pos:column="1">#<cpp:directive pos:line="984" pos:column="2">endif</cpp:directive></cpp:endif> <comment type="line" pos:line="984" pos:column="8">// MSOCI_H</comment>
</unit>
